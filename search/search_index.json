{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ModCS This is the official site for ModCS , a Cave Story modding utility, which's main feature is a Lua scripting API. The Lua API currently easily allows you to make custom HUD elements, easily modify and make NPCs and create custom TextScript commands. This project was started to give people a more accessible way to make advanced Cave Story mods, without having to deal with Assembly and the limitations of the original executable of the game. This was also started to give people a somewhat more legal way to make advanced modifications. To get started you may be interested in the Getting Started section , which contains a brief overview of basic Cave Story Modding before getting into Lua scripting. Need help with the API? Want to contribute to the documentation? Have a suggestion for the API? Join the Discord Server ! Download ModCS (0.1.1.0) All versions","title":"ModCS"},{"location":"#modcs","text":"This is the official site for ModCS , a Cave Story modding utility, which's main feature is a Lua scripting API. The Lua API currently easily allows you to make custom HUD elements, easily modify and make NPCs and create custom TextScript commands. This project was started to give people a more accessible way to make advanced Cave Story mods, without having to deal with Assembly and the limitations of the original executable of the game. This was also started to give people a somewhat more legal way to make advanced modifications. To get started you may be interested in the Getting Started section , which contains a brief overview of basic Cave Story Modding before getting into Lua scripting. Need help with the API? Want to contribute to the documentation? Have a suggestion for the API? Join the Discord Server ! Download ModCS (0.1.1.0) All versions","title":"ModCS"},{"location":"releases/","text":"ModCS Releases ModCS 0.1.1.0 Changelog Add ModCS.Npc.Caret , which contains API for spawning and modifying Carets. Credit bitmaps, Pixel.bmp and ORGs are now contained in the data folder rather than in game resources. Add caret.tbl and music.tbl files to the data folder. Add xm , ym and boost_fuel to ModCS.Player . Add ModCS.Npc.OffsetRect() . Add ModCS.Npc.CheckBit() . Add ModCS.Game.IsNew() . Fix an issue involving ModCS.Tsc.Jump() skipping characters. The title screen will now display the mod version rather than the ModCS version. Remove and fix some warnings. Update examples. Updating To update from ModCS 0.1.0.0: Replace your ModCS executable with a ModCS 0.1.1.0 one. From a vanilla ModCS 0.1.1.0 install copy the caret.tbl and music.tbl files to your mod's data folder. Move all ORG files from Resources to a data/Org folder. Move all Credit bitmaps from Resources to a data/Credits folder. Move the PIXEL bitmap from Resources to the data folder. Download Download ModCS 0.1.1.0 ModCS 0.1.0.0 Initial ModCS Release. Changelog Note This is the changelog from version 0.0.1.2, the version used for the mod Doku Goes To McDonalds . Added \"Examples\" folder to data/Scripts . Added ModCS.Surface.Screenshot() . Download Download ModCS 0.1.0.0","title":"ModCS Releases"},{"location":"releases/#modcs-releases","text":"","title":"ModCS Releases"},{"location":"releases/#modcs-0110","text":"","title":"ModCS 0.1.1.0"},{"location":"releases/#changelog","text":"Add ModCS.Npc.Caret , which contains API for spawning and modifying Carets. Credit bitmaps, Pixel.bmp and ORGs are now contained in the data folder rather than in game resources. Add caret.tbl and music.tbl files to the data folder. Add xm , ym and boost_fuel to ModCS.Player . Add ModCS.Npc.OffsetRect() . Add ModCS.Npc.CheckBit() . Add ModCS.Game.IsNew() . Fix an issue involving ModCS.Tsc.Jump() skipping characters. The title screen will now display the mod version rather than the ModCS version. Remove and fix some warnings. Update examples.","title":"Changelog"},{"location":"releases/#updating","text":"To update from ModCS 0.1.0.0: Replace your ModCS executable with a ModCS 0.1.1.0 one. From a vanilla ModCS 0.1.1.0 install copy the caret.tbl and music.tbl files to your mod's data folder. Move all ORG files from Resources to a data/Org folder. Move all Credit bitmaps from Resources to a data/Credits folder. Move the PIXEL bitmap from Resources to the data folder.","title":"Updating"},{"location":"releases/#download","text":"Download ModCS 0.1.1.0","title":"Download"},{"location":"releases/#modcs-0100","text":"Initial ModCS Release.","title":"ModCS 0.1.0.0"},{"location":"releases/#changelog_1","text":"Note This is the changelog from version 0.0.1.2, the version used for the mod Doku Goes To McDonalds . Added \"Examples\" folder to data/Scripts . Added ModCS.Surface.Screenshot() .","title":"Changelog"},{"location":"releases/#download_1","text":"Download ModCS 0.1.0.0","title":"Download"},{"location":"api/game/","text":"ModCS.Game Functions related to the main game loop. Stored in the ModCS.Game object. Warning The main game loop does not include: The inventory screen The stage select screen Minimap screen Credits Pause screen Functions such as ModCS.Game.Act() and ModCS.Game.Draw() will not run during these screens. ModCS.Game.GetMode() Return a number that represents the current game mode. Value Game mode 1 Opening sequence. 2 Title screen. 3 Action. ModCS.Game.IsNew() Returns true if the 'New' option in the title screen was selected. Returns false otherwise. ModCS.Game.Init() This function is called whenever a game mode is started. Example This example will clear a variable foo on every game mode start. 1 2 3 4 function ModCS . Game . Init () -- Clear our foo variable foo = 0 end ModCS.Game.Act() This function is called every frame before anything is drawn in the main game loop. Example This example will add 1 to a variable foo every frame. 1 2 3 4 function ModCS . Game . Act () -- Add 1 to our foo variable every frame foo = foo + 1 end ModCS.Game.Draw() This function is called every frame after everything is drawn in the main game loop. Example This example will draw the value of the variable foo using ModCS.PutNumber . 1 2 3 4 function ModCS . Game . Draw () -- Draw the value of our variable ModCS . PutNumber ( foo , 0 , 0 ) end Note ModCS.Game.Draw() will draw over everything . If you're planning on using it for custom HUD it's recommended to draw to the custom HUD Surface instead.","title":"ModCS.Game"},{"location":"api/game/#modcsgame","text":"Functions related to the main game loop. Stored in the ModCS.Game object. Warning The main game loop does not include: The inventory screen The stage select screen Minimap screen Credits Pause screen Functions such as ModCS.Game.Act() and ModCS.Game.Draw() will not run during these screens.","title":"ModCS.Game"},{"location":"api/game/#modcsgamegetmode","text":"Return a number that represents the current game mode. Value Game mode 1 Opening sequence. 2 Title screen. 3 Action.","title":"ModCS.Game.GetMode()"},{"location":"api/game/#modcsgameisnew","text":"Returns true if the 'New' option in the title screen was selected. Returns false otherwise.","title":"ModCS.Game.IsNew()"},{"location":"api/game/#modcsgameinit","text":"This function is called whenever a game mode is started. Example This example will clear a variable foo on every game mode start. 1 2 3 4 function ModCS . Game . Init () -- Clear our foo variable foo = 0 end","title":"ModCS.Game.Init()"},{"location":"api/game/#modcsgameact","text":"This function is called every frame before anything is drawn in the main game loop. Example This example will add 1 to a variable foo every frame. 1 2 3 4 function ModCS . Game . Act () -- Add 1 to our foo variable every frame foo = foo + 1 end","title":"ModCS.Game.Act()"},{"location":"api/game/#modcsgamedraw","text":"This function is called every frame after everything is drawn in the main game loop. Example This example will draw the value of the variable foo using ModCS.PutNumber . 1 2 3 4 function ModCS . Game . Draw () -- Draw the value of our variable ModCS . PutNumber ( foo , 0 , 0 ) end Note ModCS.Game.Draw() will draw over everything . If you're planning on using it for custom HUD it's recommended to draw to the custom HUD Surface instead.","title":"ModCS.Game.Draw()"},{"location":"api/key/","text":"ModCS.Key The ModCS.Key namespace contains functions for checking key presses. All ModCS.Key functions follow a similar format: ModCS . Key . Button ( hold ) Returns true if the button is being pressed. hold is an optional parameter and a Boolean. If set to true the function will return true if the button is being held. List of functions ModCS . Key . Jump ( hold ) -- Can be set to either Z or X in DoConfig ModCS . Key . Shoot ( hold ) -- Can be set to either X or Z in DoConfig ModCS . Key . Arms ( hold ) -- A key ModCS . Key . ArmsRev ( hold ) -- S key ModCS . Key . Item ( hold ) -- Q key ModCS . Key . Map ( hold ) -- W key ModCS . Key . Ok ( hold ) -- Can be either the Jump button or Shoot button in DoConfig ModCS . Key . Cancel ( hold ) -- Can be either the Shoot button or Jump button in DoConfig ModCS . Key . Left ( hold ) -- Can be either Left arrow key or < in DoConfig ModCS . Key . Up ( hold ) -- Can be either Up arrow key or L in DoConfig ModCS . Key . Right ( hold ) -- Can be either Right arrow key or ? in DoConfig ModCS . Key . Down ( hold ) -- Can be either Down arrow key or > in DoConfig","title":"ModCS.Key"},{"location":"api/key/#modcskey","text":"The ModCS.Key namespace contains functions for checking key presses. All ModCS.Key functions follow a similar format: ModCS . Key . Button ( hold ) Returns true if the button is being pressed. hold is an optional parameter and a Boolean. If set to true the function will return true if the button is being held.","title":"ModCS.Key"},{"location":"api/key/#list-of-functions","text":"ModCS . Key . Jump ( hold ) -- Can be set to either Z or X in DoConfig ModCS . Key . Shoot ( hold ) -- Can be set to either X or Z in DoConfig ModCS . Key . Arms ( hold ) -- A key ModCS . Key . ArmsRev ( hold ) -- S key ModCS . Key . Item ( hold ) -- Q key ModCS . Key . Map ( hold ) -- W key ModCS . Key . Ok ( hold ) -- Can be either the Jump button or Shoot button in DoConfig ModCS . Key . Cancel ( hold ) -- Can be either the Shoot button or Jump button in DoConfig ModCS . Key . Left ( hold ) -- Can be either Left arrow key or < in DoConfig ModCS . Key . Up ( hold ) -- Can be either Up arrow key or L in DoConfig ModCS . Key . Right ( hold ) -- Can be either Right arrow key or ? in DoConfig ModCS . Key . Down ( hold ) -- Can be either Down arrow key or > in DoConfig","title":"List of functions"},{"location":"api/map/","text":"ModCS.Map The ModCS.Map namespace contains functions related to Maps. Maps are a collection of files stored in the /data/Stage/ folder. They are only usuable in-game via a Stage . Maps are composed of 3 types of files: PXM (PixMap) files - For storing tile placement. PXE (PixEvent or PixEntity) - For storing NPC placement. TSC Files - For storing an individual map's TextScript . Tile Unit Map files (TSC included) use Tile Units for coordinates rather than Pixel Units . One Tile Unit is 16x16 Pixel Units. ModCS.Map.GetWidth() ModCS . Map . GetWidth () Returns the width in tile units of the current loaded map. ModCS.Map.GetHeight() ModCS . Map . GetHeight () Returns the height in tile units of the current loaded map. ModCS.Map.GetFilename() ModCS . Map . GetAttribute ( x , y ) Returns the attribute of the tile at tile unit coordinates x and y . ModCS.Map.ChangeTile() ModCS . Map . ChangeTile ( no , x , y , smoke ) Changes the tile at tile unit coordinates x and y of the current map to tile no . smoke is an optional parameter and a Boolean. If set to true, spawn smoke NPCs at the position of the changing tile.","title":"ModCS.Map"},{"location":"api/map/#modcsmap","text":"The ModCS.Map namespace contains functions related to Maps. Maps are a collection of files stored in the /data/Stage/ folder. They are only usuable in-game via a Stage . Maps are composed of 3 types of files: PXM (PixMap) files - For storing tile placement. PXE (PixEvent or PixEntity) - For storing NPC placement. TSC Files - For storing an individual map's TextScript .","title":"ModCS.Map"},{"location":"api/map/#tile-unit","text":"Map files (TSC included) use Tile Units for coordinates rather than Pixel Units . One Tile Unit is 16x16 Pixel Units.","title":"Tile Unit"},{"location":"api/map/#modcsmapgetwidth","text":"ModCS . Map . GetWidth () Returns the width in tile units of the current loaded map.","title":"ModCS.Map.GetWidth()"},{"location":"api/map/#modcsmapgetheight","text":"ModCS . Map . GetHeight () Returns the height in tile units of the current loaded map.","title":"ModCS.Map.GetHeight()"},{"location":"api/map/#modcsmapgetfilename","text":"ModCS . Map . GetAttribute ( x , y ) Returns the attribute of the tile at tile unit coordinates x and y .","title":"ModCS.Map.GetFilename()"},{"location":"api/map/#modcsmapchangetile","text":"ModCS . Map . ChangeTile ( no , x , y , smoke ) Changes the tile at tile unit coordinates x and y of the current map to tile no . smoke is an optional parameter and a Boolean. If set to true, spawn smoke NPCs at the position of the changing tile.","title":"ModCS.Map.ChangeTile()"},{"location":"api/mod/","text":"ModCS.Mod The ModCS.Mod namespace contains functions related to customizing releases of mods. ModCS.Mod.SetName() ModCS . Mod . SetName ( name ) Sets the window title of the game to name . This function will only work at top-level. ModCS.Mod.SetAuthor() ModCS . Mod . SetAuthor ( name ) Sets the author of game to name . The author will be displayed in the version window. ModCS.Mod.SetVersion() ModCS . Mod . SetVersion ( v1 , v2 , v3 , v4 ) Sets the version of the game to v1 . v2 . v3 . v4 . This version will be in the version window. ModCS.Mod.SetOpening() ModCS . Mod . SetOpening ( no , eve , wait ) Use Stage no for the opening sequence ( Game Mode 1). eve and wait are optional parameters. If eve is specified Event eve will run once the opening sequence starts, otherwise Event 0 will run. If wait is specified, wait wait ticks during the opening before transferring to the title screen. ModCS.Mod.SetStart() ModCS . Mod . SetStart ( no , x , y , eve ) Sets the default New Game starting point. Parameters are the same as the ModCS.Stage.Transfer() function .","title":"ModCS.Mod"},{"location":"api/mod/#modcsmod","text":"The ModCS.Mod namespace contains functions related to customizing releases of mods.","title":"ModCS.Mod"},{"location":"api/mod/#modcsmodsetname","text":"ModCS . Mod . SetName ( name ) Sets the window title of the game to name . This function will only work at top-level.","title":"ModCS.Mod.SetName()"},{"location":"api/mod/#modcsmodsetauthor","text":"ModCS . Mod . SetAuthor ( name ) Sets the author of game to name . The author will be displayed in the version window.","title":"ModCS.Mod.SetAuthor()"},{"location":"api/mod/#modcsmodsetversion","text":"ModCS . Mod . SetVersion ( v1 , v2 , v3 , v4 ) Sets the version of the game to v1 . v2 . v3 . v4 . This version will be in the version window.","title":"ModCS.Mod.SetVersion()"},{"location":"api/mod/#modcsmodsetopening","text":"ModCS . Mod . SetOpening ( no , eve , wait ) Use Stage no for the opening sequence ( Game Mode 1). eve and wait are optional parameters. If eve is specified Event eve will run once the opening sequence starts, otherwise Event 0 will run. If wait is specified, wait wait ticks during the opening before transferring to the title screen.","title":"ModCS.Mod.SetOpening()"},{"location":"api/mod/#modcsmodsetstart","text":"ModCS . Mod . SetStart ( no , x , y , eve ) Sets the default New Game starting point. Parameters are the same as the ModCS.Stage.Transfer() function .","title":"ModCS.Mod.SetStart()"},{"location":"api/modcs/","text":"ModCS Object - Basics All of ModCS's API is contained in the ModCS global namespace . ModCS.WriteLog() ModCS . WriteLog ( text , number1 , number2 , number3 ) Write given data to a debug.txt file located in the same directory as the executable. All number parameters are optional, and will be casted to integers. ModCS.PutText() ModCS . PutText ( text , x , y , color , surface ) Draw given text to screen at coordinates x and y . color and surface parameters are optional. If a color is not specified the text will have the color 255, 255, 254 ( #FFFFFE ). When a surface is specified, ModCS.PutText will draw to given surface instead. ModCS.PutNumber() ModCS . PutNumber ( number , x , y , zero , surface ) Draw given number to screen at coordinates x and y . zero and surface parameters are optional. Number parameters over 9999 will display capped. zero is a Boolean. If set to true a zero will be shown to the left of the number. This only applies to one-digit numbers. When a surface is specified, ModCS.PutNumber will draw to given surface instead. ModCS.GetFullRect() Returns a full ModCS.Rect . This rect will usually equal to this: { left = 0 , top = 0 , right = 320 , bottom = 240 } ModCS.GetGameRect() Returns the canvas ModCS.Rect of the game. This rect will usually equal to this: { left = 0 , top = 0 , right = 320 , bottom = 240 } During the credits sequence the rect's left value will equal to 160. Note The main difference between ModCS.GetGameRect() and ModCS.GetFullRect() is how both values are used in the original game itself. The full Rect is often the default view limitng value for drawing a bitmap, while the game Rect is the view limiting value for game related objects (NPCs, player, map tiles, etc.). You can use these Rects with ModCS.Rect.PutEx()","title":"ModCS Object - Basics"},{"location":"api/modcs/#modcs-object-basics","text":"All of ModCS's API is contained in the ModCS global namespace .","title":"ModCS Object - Basics"},{"location":"api/modcs/#modcswritelog","text":"ModCS . WriteLog ( text , number1 , number2 , number3 ) Write given data to a debug.txt file located in the same directory as the executable. All number parameters are optional, and will be casted to integers.","title":"ModCS.WriteLog()"},{"location":"api/modcs/#modcsputtext","text":"ModCS . PutText ( text , x , y , color , surface ) Draw given text to screen at coordinates x and y . color and surface parameters are optional. If a color is not specified the text will have the color 255, 255, 254 ( #FFFFFE ). When a surface is specified, ModCS.PutText will draw to given surface instead.","title":"ModCS.PutText()"},{"location":"api/modcs/#modcsputnumber","text":"ModCS . PutNumber ( number , x , y , zero , surface ) Draw given number to screen at coordinates x and y . zero and surface parameters are optional. Number parameters over 9999 will display capped. zero is a Boolean. If set to true a zero will be shown to the left of the number. This only applies to one-digit numbers. When a surface is specified, ModCS.PutNumber will draw to given surface instead.","title":"ModCS.PutNumber()"},{"location":"api/modcs/#modcsgetfullrect","text":"Returns a full ModCS.Rect . This rect will usually equal to this: { left = 0 , top = 0 , right = 320 , bottom = 240 }","title":"ModCS.GetFullRect()"},{"location":"api/modcs/#modcsgetgamerect","text":"Returns the canvas ModCS.Rect of the game. This rect will usually equal to this: { left = 0 , top = 0 , right = 320 , bottom = 240 } During the credits sequence the rect's left value will equal to 160. Note The main difference between ModCS.GetGameRect() and ModCS.GetFullRect() is how both values are used in the original game itself. The full Rect is often the default view limitng value for drawing a bitmap, while the game Rect is the view limiting value for game related objects (NPCs, player, map tiles, etc.). You can use these Rects with ModCS.Rect.PutEx()","title":"ModCS.GetGameRect()"},{"location":"api/options/","text":"Extra Options Vanilla Cave Story has some extra functionality if certain empty files without file extension are present in the same directory as the EXE. Vanilla Options s_reverse - Swaps the weapon switch keys. mute - Unhides a context menu which opens a window for muting different Organya channels. fps - Enables a Framerate counter. ModCS Options These options are not present in vanilla, but were added in ModCS. debug - Enables the Debug Console and unhides the \"Debug Save\" option. ntsc - Makes the limit of the game's framerate 60 FPS.","title":"Extra Options"},{"location":"api/options/#extra-options","text":"Vanilla Cave Story has some extra functionality if certain empty files without file extension are present in the same directory as the EXE.","title":"Extra Options"},{"location":"api/options/#vanilla-options","text":"s_reverse - Swaps the weapon switch keys. mute - Unhides a context menu which opens a window for muting different Organya channels. fps - Enables a Framerate counter.","title":"Vanilla Options"},{"location":"api/options/#modcs-options","text":"These options are not present in vanilla, but were added in ModCS. debug - Enables the Debug Console and unhides the \"Debug Save\" option. ntsc - Makes the limit of the game's framerate 60 FPS.","title":"ModCS Options"},{"location":"api/stage/","text":"ModCS.Stage The ModCS.Stage namespace contains functions related to Stages. Stage Table The stage table is where all of the game's stages are defined. A stage table entry has the following values: Value Usage Map Filename The filename used for loading map and TSC files. Stage Name The name of the stage that will be shown in the minimap and in <MNA . Tileset The filename used for loading the tileset bitmap and PXA file. NPC Sheet 1 Filename The filename used for loading a bitmap to the NPC Spritesheet 1 surface . NPC Sheet 2 Filename The filename used for loading a bitmap to the NPC Spritesheet 2 surface . Background Filename The filename used for loading a bitmap to the Background surface . Background Scroll Type A number which represents how the background will act. Boss Number i am being forced to write these docs please send help The Stage Table is stored in a stage.tbl file that can be found in the data folder. Usually Cave Story map editors heavily depend on the Stage Table to load the correct tilesets, backgrounds and NPC Sheets when the user wants to edit a map. Most editors also do not allow you to edit maps which do not have a defined stage. Note In the original game the Stage Table is not stored in a seperate file but hardcoded into the game executable instead. ModCS.Stage.Transfer() ModCS . Stage . Transfer ( no , x , y , eve ) Transfer to stage no . If x and y are specified, change the player's tile coordinates to x and y . If eve is specified, run TSC Event eve after transferring to the stage. Run Event 0 otherwise. ModCS.Stage.GetCurrentNo() ModCS . Stage . GetCurrentNo () Returns the current stage's number. ModCS.Stage.GetFilename() ModCS . Stage . GetFilename ( no ) no is an optional parameter. Returns the filename value of stage table entry no . If no is not specified, return the filename value of the current stage. ModCS.Stage.GetName() ModCS . Stage . GetName ( no ) no is an optional parameter. Returns the stage name value of stage table entry no . If no is not specified, return the stage name value of the current stage.","title":"ModCS.Stage"},{"location":"api/stage/#modcsstage","text":"The ModCS.Stage namespace contains functions related to Stages.","title":"ModCS.Stage"},{"location":"api/stage/#stage-table","text":"The stage table is where all of the game's stages are defined. A stage table entry has the following values: Value Usage Map Filename The filename used for loading map and TSC files. Stage Name The name of the stage that will be shown in the minimap and in <MNA . Tileset The filename used for loading the tileset bitmap and PXA file. NPC Sheet 1 Filename The filename used for loading a bitmap to the NPC Spritesheet 1 surface . NPC Sheet 2 Filename The filename used for loading a bitmap to the NPC Spritesheet 2 surface . Background Filename The filename used for loading a bitmap to the Background surface . Background Scroll Type A number which represents how the background will act. Boss Number i am being forced to write these docs please send help The Stage Table is stored in a stage.tbl file that can be found in the data folder. Usually Cave Story map editors heavily depend on the Stage Table to load the correct tilesets, backgrounds and NPC Sheets when the user wants to edit a map. Most editors also do not allow you to edit maps which do not have a defined stage. Note In the original game the Stage Table is not stored in a seperate file but hardcoded into the game executable instead.","title":"Stage Table"},{"location":"api/stage/#modcsstagetransfer","text":"ModCS . Stage . Transfer ( no , x , y , eve ) Transfer to stage no . If x and y are specified, change the player's tile coordinates to x and y . If eve is specified, run TSC Event eve after transferring to the stage. Run Event 0 otherwise.","title":"ModCS.Stage.Transfer()"},{"location":"api/stage/#modcsstagegetcurrentno","text":"ModCS . Stage . GetCurrentNo () Returns the current stage's number.","title":"ModCS.Stage.GetCurrentNo()"},{"location":"api/stage/#modcsstagegetfilename","text":"ModCS . Stage . GetFilename ( no ) no is an optional parameter. Returns the filename value of stage table entry no . If no is not specified, return the filename value of the current stage.","title":"ModCS.Stage.GetFilename()"},{"location":"api/stage/#modcsstagegetname","text":"ModCS . Stage . GetName ( no ) no is an optional parameter. Returns the stage name value of stage table entry no . If no is not specified, return the stage name value of the current stage.","title":"ModCS.Stage.GetName()"},{"location":"api/tsc/","text":"ModCS.Tsc The ModCS.Tsc namespace contains functions related to TextScript (Also known as T-Script). TextScript is vanilla Cave Story's scripting language. Combined with Flags it's used for textboxes, animations, cutscenes, etc. Commands TextScript's syntax is composed of commands (or \"codes\") that do certain actions. When the TSC parser reaches a < symbol it checks the next 3 symbols and compares them to its list of commands. If no command is found an error will occur. ... Here I would put my own TSC command list but I'm currently too lazy. Please refer to your map editor's TSC list or this TXT list instead. Events TextScript scripts are seperated into Events , which are runnable sets of actions and text. Events are a defined with a # and 4 following digits, which together represent the Event number. Events are usually ended with <END . Example This is a basic TSC example event which opens a textbox. #0100 <KEY<MSGHello World<NOD<CLO<END ModCS.Tsc.Run() ModCS . Tsc . Run ( event ) Run TextScript Event event . Warning It's recommended to only use ModCS.Tsc.Run() when a TextScript event isn't running. If you want to run a different Event during another Event please use ModCS.Tsc.Jump() instead. ModCS.Tsc.Jump() ModCS . Tsc . Jump ( event ) Jump to TextScript Event event while another Event is running. ModCS.Tsc.Wait() ModCS . Tsc . Wait ( ticks ) During a TextScript event, wait ticks ticks before running the next command. ModCS.Tsc.GetArgument() ModCS . Tsc . GetArgument ( no ) During a custom TextScript command, get the no argument of the running command. Calling this function will also 'skip' the argument from the TSC parser. Custom Commands ModCS allows you to have custom TextScript commands. If a function ModCS.Tsc.CommandXXX is defined (where XXX is the custom command) the function will run when the TextScript parser reaches command <XXX . Example This is an example function for a TextScript command that will print its first argument to the debug console. 1 2 3 4 function ModCS . Tsc . CommandFOO () local no = ModCS . Tsc . GetArgument ( 1 ) -- Get the first argument of the running command print ( no ) end #0100 <FOO0002<END Console output: 2","title":"ModCS.Tsc"},{"location":"api/tsc/#modcstsc","text":"The ModCS.Tsc namespace contains functions related to TextScript (Also known as T-Script). TextScript is vanilla Cave Story's scripting language. Combined with Flags it's used for textboxes, animations, cutscenes, etc.","title":"ModCS.Tsc"},{"location":"api/tsc/#commands","text":"TextScript's syntax is composed of commands (or \"codes\") that do certain actions. When the TSC parser reaches a < symbol it checks the next 3 symbols and compares them to its list of commands. If no command is found an error will occur. ... Here I would put my own TSC command list but I'm currently too lazy. Please refer to your map editor's TSC list or this TXT list instead.","title":"Commands"},{"location":"api/tsc/#events","text":"TextScript scripts are seperated into Events , which are runnable sets of actions and text. Events are a defined with a # and 4 following digits, which together represent the Event number. Events are usually ended with <END . Example This is a basic TSC example event which opens a textbox. #0100 <KEY<MSGHello World<NOD<CLO<END","title":"Events"},{"location":"api/tsc/#modcstscrun","text":"ModCS . Tsc . Run ( event ) Run TextScript Event event . Warning It's recommended to only use ModCS.Tsc.Run() when a TextScript event isn't running. If you want to run a different Event during another Event please use ModCS.Tsc.Jump() instead.","title":"ModCS.Tsc.Run()"},{"location":"api/tsc/#modcstscjump","text":"ModCS . Tsc . Jump ( event ) Jump to TextScript Event event while another Event is running.","title":"ModCS.Tsc.Jump()"},{"location":"api/tsc/#modcstscwait","text":"ModCS . Tsc . Wait ( ticks ) During a TextScript event, wait ticks ticks before running the next command.","title":"ModCS.Tsc.Wait()"},{"location":"api/tsc/#modcstscgetargument","text":"ModCS . Tsc . GetArgument ( no ) During a custom TextScript command, get the no argument of the running command. Calling this function will also 'skip' the argument from the TSC parser.","title":"ModCS.Tsc.GetArgument()"},{"location":"api/tsc/#custom-commands","text":"ModCS allows you to have custom TextScript commands. If a function ModCS.Tsc.CommandXXX is defined (where XXX is the custom command) the function will run when the TextScript parser reaches command <XXX . Example This is an example function for a TextScript command that will print its first argument to the debug console. 1 2 3 4 function ModCS . Tsc . CommandFOO () local no = ModCS . Tsc . GetArgument ( 1 ) -- Get the first argument of the running command print ( no ) end #0100 <FOO0002<END Console output: 2","title":"Custom Commands"},{"location":"api/drawing/color/","text":"ModCS.Color The ModCS.Color class represents colors. They are stored in a RGB format. A ModCS.Color is userdata. You may access and edit the following values from it: Value Type Usage red Number (Casted to integer) Red value of an RGB color (0-255). green Number (Casted to integer) Green value of an RGB color (0-255). blue Number (Casted to integer) Blue value of an RGB color (0-255). ModCS.Color.Create() ModCS . Color . Create ( red , green , blue ) Returns a ModCS.Color. All parameters are optional. If any parameters are given, the returned ModCS.Color will use those parameters as RGB values. ModCS.Color.Set() ModCS . Color . Set ( color , red , green , blue ) Sets the ModCS.Color given in the color parameter to a ModCS.Color with the following parameters. ModCS.Color.Box() ModCS . Color . Box ( color , x , y , width , height , surface ) ModCS . Color . Box ( color , rect , surface ) Draw a colored box to the screen at coordinates x and y with width width and height height . The surface parameter is optional. If it's specified, draw a colored box to surface with ID surface instead. Note For a more traditional CortBox usage you may specify a rect instead of coordinates and size.","title":"ModCS.Color"},{"location":"api/drawing/color/#modcscolor","text":"The ModCS.Color class represents colors. They are stored in a RGB format. A ModCS.Color is userdata. You may access and edit the following values from it: Value Type Usage red Number (Casted to integer) Red value of an RGB color (0-255). green Number (Casted to integer) Green value of an RGB color (0-255). blue Number (Casted to integer) Blue value of an RGB color (0-255).","title":"ModCS.Color"},{"location":"api/drawing/color/#modcscolorcreate","text":"ModCS . Color . Create ( red , green , blue ) Returns a ModCS.Color. All parameters are optional. If any parameters are given, the returned ModCS.Color will use those parameters as RGB values.","title":"ModCS.Color.Create()"},{"location":"api/drawing/color/#modcscolorset","text":"ModCS . Color . Set ( color , red , green , blue ) Sets the ModCS.Color given in the color parameter to a ModCS.Color with the following parameters.","title":"ModCS.Color.Set()"},{"location":"api/drawing/color/#modcscolorbox","text":"ModCS . Color . Box ( color , x , y , width , height , surface ) ModCS . Color . Box ( color , rect , surface ) Draw a colored box to the screen at coordinates x and y with width width and height height . The surface parameter is optional. If it's specified, draw a colored box to surface with ID surface instead. Note For a more traditional CortBox usage you may specify a rect instead of coordinates and size.","title":"ModCS.Color.Box()"},{"location":"api/drawing/rect/","text":"ModCS.Rect The ModCS.Rect class represents Rects. They are a collection of pixel coordinates on a Surface which represent a part of the surface. They are mostly used for displaying different sprites from a spritesheet. A ModCS.Rect is userdata. You may access and edit the following values from it: Value Type Usage left Number (Casted to integer) X coordinate of the upper-left corner of the Rect. top Number (Casted to integer) Y coordinate of the upper-left corner of the Rect. right Number (Casted to integer) X coordinate of the down-right corner of the Rect. bottom Number (Casted to integer) Y coordinate of the down-right corner of the Rect. Rect Example This example shows you how to get the Rect of the number 4 sprite from TextBox.bmp The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore, the Rect of the number 4 sprite is: { left = 32 , top = 56 , right = 40 , bottom = 64 } ModCS.Rect.Create() ModCS . Rect . Create ( left , top , right , bottom ) Returns a ModCS.Rect. All parameters are optional. If any parameters are given, the returned ModCS.Rect will use those parameters as Rect values. ModCS.Rect.Set() ModCS . Rect . Set ( rect , left , top , right , bottom ) Sets the ModCS.Rect given in the rect parameter to a ModCS.Rect with the following parameters. ModCS.Rect.Put() ModCS . Rect . Put ( rect , x , y , surface , alpha ) Draw the given Rect from the surface with ID surface to the screen with coordinates x and y . The alpha parameter is optional and is a Boolean. If set to false the game will draw the rect without removing any fully black pixels. The default value is true. Note For a more traditional PutBitmap usage you may use ModCS.Rect.PutEx() . ModCS.Rect.Put2Surface() ModCS . Rect . Put ( rect , x , y , surfacefrom , surfaceto ) Draw the given Rect from the surface with ID surfacefrom to the surface with ID surfaceto . ModCS.Rect.PutEx() ModCS . Rect . PutEx ( rect , viewrect , x , y , surface , alpha ) The same as ModCS.Rect.Put() but with a viewrect which limits the view.","title":"ModCS.Rect"},{"location":"api/drawing/rect/#modcsrect","text":"The ModCS.Rect class represents Rects. They are a collection of pixel coordinates on a Surface which represent a part of the surface. They are mostly used for displaying different sprites from a spritesheet. A ModCS.Rect is userdata. You may access and edit the following values from it: Value Type Usage left Number (Casted to integer) X coordinate of the upper-left corner of the Rect. top Number (Casted to integer) Y coordinate of the upper-left corner of the Rect. right Number (Casted to integer) X coordinate of the down-right corner of the Rect. bottom Number (Casted to integer) Y coordinate of the down-right corner of the Rect. Rect Example This example shows you how to get the Rect of the number 4 sprite from TextBox.bmp The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore, the Rect of the number 4 sprite is: { left = 32 , top = 56 , right = 40 , bottom = 64 }","title":"ModCS.Rect"},{"location":"api/drawing/rect/#modcsrectcreate","text":"ModCS . Rect . Create ( left , top , right , bottom ) Returns a ModCS.Rect. All parameters are optional. If any parameters are given, the returned ModCS.Rect will use those parameters as Rect values.","title":"ModCS.Rect.Create()"},{"location":"api/drawing/rect/#modcsrectset","text":"ModCS . Rect . Set ( rect , left , top , right , bottom ) Sets the ModCS.Rect given in the rect parameter to a ModCS.Rect with the following parameters.","title":"ModCS.Rect.Set()"},{"location":"api/drawing/rect/#modcsrectput","text":"ModCS . Rect . Put ( rect , x , y , surface , alpha ) Draw the given Rect from the surface with ID surface to the screen with coordinates x and y . The alpha parameter is optional and is a Boolean. If set to false the game will draw the rect without removing any fully black pixels. The default value is true. Note For a more traditional PutBitmap usage you may use ModCS.Rect.PutEx() .","title":"ModCS.Rect.Put()"},{"location":"api/drawing/rect/#modcsrectput2surface","text":"ModCS . Rect . Put ( rect , x , y , surfacefrom , surfaceto ) Draw the given Rect from the surface with ID surfacefrom to the surface with ID surfaceto .","title":"ModCS.Rect.Put2Surface()"},{"location":"api/drawing/rect/#modcsrectputex","text":"ModCS . Rect . PutEx ( rect , viewrect , x , y , surface , alpha ) The same as ModCS.Rect.Put() but with a viewrect which limits the view.","title":"ModCS.Rect.PutEx()"},{"location":"api/drawing/surface/","text":"ModCS.Surface The ModCS.Surface class represents drawing surfaces. Surfaces are image data types which contain pixels of an image. Surface ID Table Surfaces are represented by an ID. This table contains all vanilla game surfaces. Value Description Additional Info 0 Title screen This surface is created from the bitmap file /data/Title.bmp . 1 Studio Pixel logo This surface is created from the bitmap file <game executable data>/BITMAP/PIXEL.bmp . 2 Level tileset This surface is used by the game to draw tiles. The game loads the tileset bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 256x256. 6 Fade effect This surface is created from the bitmap file /data/Fade.bmp . 7 HUD This surface is exclusive to ModCS. The game draws all HUD elements to this surface. 8 Items This surface is created from the bitmap file /data/ItemImage.bmp . 9 Minimap This surface is used by the game to draw the Minimap. Its size is 320x240. 10 Screenshot This surface is used by the game to display game loops in other game loops. For example, when the player enters the inventory screen, the game screenshots itself and draws this screenshot to this surface. When the inventory screen is drawn the game first draws the screenshot surface as a background and then draws the inventory screen itself. This surface's size is 320x240. 11 Arms This surface is created from the bitmap file /data/Arms.bmp . 12 Arms Image This surface is created from the bitmap file /data/ArmsImage.bmp . 13 Room name This surface is used by the game for drawing the room name to. This surface's size is 160x16. 14 Stage item This surface is created from the bitmap file /data/StageImage.bmp . 15 Loading This surface is created from the bitmap file /data/Loading.bmp . 16 Player This surface is created from the bitmap file /data/MyChar.bmp . 17 Bullet This surface is created from the bitmap file /data/Bullet.bmp . 19 Caret This surface is created from the bitmap file /data/Caret.bmp . 20 NPC System This surface is created from the bitmap file /data/Npc/NpcSym.bmp . 21 NPC Spritesheet 1 The game loads the NPC Spritesheet 1 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 22 NPC Spritesheet 2 The game loads the NPC Spritesheet 2 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 23 NPC Regular This surface is created from the bitmap file /data/Npc/NpcRegu.bmp . 26 Textbox This surface is created from the bitmap file /data/TextBox.bmp . 27 Face This surface is created from the bitmap file /data/Face.bmp . 28 Level background The game loads the Background bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 29 Value view The game draws damage and XP indicators to this surface. This surface's size is 40x240. 30-34 Text line surfaces from 1 to 5 These surfaces are used by the game for drawing TSC text to. These surfaces are only initialized when TSC starts. Their size is 216x16. The game needs 5 of these for the text scrolling effect. 35 Credits text This surface is used by the game for drawing the credits text to. Its height varies on the credits TSC, but its width is 320. 36 Credits image This surface is created from the bitmap file <game executable data>/BITMAP/CREDIT01.bmp . It can be swapped with other CREDIT bitmaps during the credits TSC. 37 Casts This surface is created from the bitmap file /data/Npc/casts.bmp when the credits start. Note In the original game, more than 40 surfaces could not be created. In ModCS this number has been increased to 50 to allow for more custom surfaces. ModCS.Surface.Create() ModCS . Surface . Create ( id , width , height ) ModCS . Surface . Create ( id , path ) Create a surface. Returns a ModCS.Surface which contains the ID of the surface. If width and height are specified, create a generic surface with those sizes. If a path is specified, create a surface with the bitmap given in that path. The path's root is always the game's data folder. Do not add a .bmp file extension to the path. Surfaces created from bitmap files use the specified bitmap file's size. Example This example will create two surfaces, one basic and one from a file. 1 2 BarSurface = ModCS . Surface . Create ( 41 , 320 , 240 ) -- Create a surface with ID 41 with size 320x240 FooSurface = ModCS . Surface . Create ( 42 , \"Foo\" ) -- Create a surface with ID 42 using /data/Foo.bmp Note When creating custom surfaces, it's reccomended to use surface IDs over 40, as it's possible in the future for ModCS to add new custom surfaces below this number. ModCS.Surface.LoadBitmap() ModCS . Surface . LoadBitmap ( id , path ) Draw the bitmap file specified in path to a surface with ID id . The path's root is always the game's data folder. Do not add a .bmp file extension to the path. ModCS.Surface.Screenshot() ModCS . Surface . Screenshot ( id , rect ) Draw a screenshot of the current state of the game to Surface with ID id . rect is an optional parameter. If specified only rect of the screen will be drawn to the Surface.","title":"ModCS.Surface"},{"location":"api/drawing/surface/#modcssurface","text":"The ModCS.Surface class represents drawing surfaces. Surfaces are image data types which contain pixels of an image.","title":"ModCS.Surface"},{"location":"api/drawing/surface/#surface-id-table","text":"Surfaces are represented by an ID. This table contains all vanilla game surfaces. Value Description Additional Info 0 Title screen This surface is created from the bitmap file /data/Title.bmp . 1 Studio Pixel logo This surface is created from the bitmap file <game executable data>/BITMAP/PIXEL.bmp . 2 Level tileset This surface is used by the game to draw tiles. The game loads the tileset bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 256x256. 6 Fade effect This surface is created from the bitmap file /data/Fade.bmp . 7 HUD This surface is exclusive to ModCS. The game draws all HUD elements to this surface. 8 Items This surface is created from the bitmap file /data/ItemImage.bmp . 9 Minimap This surface is used by the game to draw the Minimap. Its size is 320x240. 10 Screenshot This surface is used by the game to display game loops in other game loops. For example, when the player enters the inventory screen, the game screenshots itself and draws this screenshot to this surface. When the inventory screen is drawn the game first draws the screenshot surface as a background and then draws the inventory screen itself. This surface's size is 320x240. 11 Arms This surface is created from the bitmap file /data/Arms.bmp . 12 Arms Image This surface is created from the bitmap file /data/ArmsImage.bmp . 13 Room name This surface is used by the game for drawing the room name to. This surface's size is 160x16. 14 Stage item This surface is created from the bitmap file /data/StageImage.bmp . 15 Loading This surface is created from the bitmap file /data/Loading.bmp . 16 Player This surface is created from the bitmap file /data/MyChar.bmp . 17 Bullet This surface is created from the bitmap file /data/Bullet.bmp . 19 Caret This surface is created from the bitmap file /data/Caret.bmp . 20 NPC System This surface is created from the bitmap file /data/Npc/NpcSym.bmp . 21 NPC Spritesheet 1 The game loads the NPC Spritesheet 1 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 22 NPC Spritesheet 2 The game loads the NPC Spritesheet 2 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 23 NPC Regular This surface is created from the bitmap file /data/Npc/NpcRegu.bmp . 26 Textbox This surface is created from the bitmap file /data/TextBox.bmp . 27 Face This surface is created from the bitmap file /data/Face.bmp . 28 Level background The game loads the Background bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 29 Value view The game draws damage and XP indicators to this surface. This surface's size is 40x240. 30-34 Text line surfaces from 1 to 5 These surfaces are used by the game for drawing TSC text to. These surfaces are only initialized when TSC starts. Their size is 216x16. The game needs 5 of these for the text scrolling effect. 35 Credits text This surface is used by the game for drawing the credits text to. Its height varies on the credits TSC, but its width is 320. 36 Credits image This surface is created from the bitmap file <game executable data>/BITMAP/CREDIT01.bmp . It can be swapped with other CREDIT bitmaps during the credits TSC. 37 Casts This surface is created from the bitmap file /data/Npc/casts.bmp when the credits start. Note In the original game, more than 40 surfaces could not be created. In ModCS this number has been increased to 50 to allow for more custom surfaces.","title":"Surface ID Table"},{"location":"api/drawing/surface/#modcssurfacecreate","text":"ModCS . Surface . Create ( id , width , height ) ModCS . Surface . Create ( id , path ) Create a surface. Returns a ModCS.Surface which contains the ID of the surface. If width and height are specified, create a generic surface with those sizes. If a path is specified, create a surface with the bitmap given in that path. The path's root is always the game's data folder. Do not add a .bmp file extension to the path. Surfaces created from bitmap files use the specified bitmap file's size. Example This example will create two surfaces, one basic and one from a file. 1 2 BarSurface = ModCS . Surface . Create ( 41 , 320 , 240 ) -- Create a surface with ID 41 with size 320x240 FooSurface = ModCS . Surface . Create ( 42 , \"Foo\" ) -- Create a surface with ID 42 using /data/Foo.bmp Note When creating custom surfaces, it's reccomended to use surface IDs over 40, as it's possible in the future for ModCS to add new custom surfaces below this number.","title":"ModCS.Surface.Create()"},{"location":"api/drawing/surface/#modcssurfaceloadbitmap","text":"ModCS . Surface . LoadBitmap ( id , path ) Draw the bitmap file specified in path to a surface with ID id . The path's root is always the game's data folder. Do not add a .bmp file extension to the path.","title":"ModCS.Surface.LoadBitmap()"},{"location":"api/drawing/surface/#modcssurfacescreenshot","text":"ModCS . Surface . Screenshot ( id , rect ) Draw a screenshot of the current state of the game to Surface with ID id . rect is an optional parameter. If specified only rect of the screen will be drawn to the Surface.","title":"ModCS.Surface.Screenshot()"},{"location":"api/flags/flag/","text":"ModCS.Flag The ModCS.Flag namespace contains functions related to Flags. Flags are in-game \"switches\" that are used to record the player's progress, and are saved to the save file when the player saves the game. The maximum flag is 8000. Hardcoded flags There are two flags that change game properties outside of TSC: If flag 4000 is set, when the player drowns, instead of the normal drown event, event 1100 will start. This is used in the vanilla game for the after Core boss cutscene. If flag 563 is not set, the Curly AI NPC will not shoot bullets. (Citation needed) ModCS.Flag.Set() ModCS . Flag . Set ( no ) Sets (Or \"Switches on\") the flag no . ModCS.Flag.Unset() ModCS . Flag . UnSet ( no ) Unsets (Or \"Switches off\") the flag no . ModCS.Flag.Get() ModCS . Flag . Get ( no ) Returns true if the flag no is set. Returns false otherwise.","title":"ModCS.Flag"},{"location":"api/flags/flag/#modcsflag","text":"The ModCS.Flag namespace contains functions related to Flags. Flags are in-game \"switches\" that are used to record the player's progress, and are saved to the save file when the player saves the game. The maximum flag is 8000.","title":"ModCS.Flag"},{"location":"api/flags/flag/#hardcoded-flags","text":"There are two flags that change game properties outside of TSC: If flag 4000 is set, when the player drowns, instead of the normal drown event, event 1100 will start. This is used in the vanilla game for the after Core boss cutscene. If flag 563 is not set, the Curly AI NPC will not shoot bullets. (Citation needed)","title":"Hardcoded flags"},{"location":"api/flags/flag/#modcsflagset","text":"ModCS . Flag . Set ( no ) Sets (Or \"Switches on\") the flag no .","title":"ModCS.Flag.Set()"},{"location":"api/flags/flag/#modcsflagunset","text":"ModCS . Flag . UnSet ( no ) Unsets (Or \"Switches off\") the flag no .","title":"ModCS.Flag.Unset()"},{"location":"api/flags/flag/#modcsflagget","text":"ModCS . Flag . Get ( no ) Returns true if the flag no is set. Returns false otherwise.","title":"ModCS.Flag.Get()"},{"location":"api/flags/skipflag/","text":"ModCS.SkipFlag The ModCS.SkipFlag namespace contains functions related to Skipflags. Unlike Flags Skipflags do not save to the save file and will reset if the player closes the game. They are used if the player dies after viewing a long cutscene and would have to rewatch a cutscene if a skipflag was not used for it. The maximum skipflag is 64. ModCS.SkipFlag.Set() ModCS . SkipFlag . Set ( no ) Sets (Or \"Switches on\") the skipflag no . ModCS.SkipFlag.Unset() ModCS . SkipFlag . UnSet ( no ) Unsets (Or \"Switches off\") the skipflag no . ModCS.SkipFlag.Get() ModCS . SkipFlag . Get ( no ) Returns true if the skipflag no is set. Returns false otherwise.","title":"ModCS.SkipFlag"},{"location":"api/flags/skipflag/#modcsskipflag","text":"The ModCS.SkipFlag namespace contains functions related to Skipflags. Unlike Flags Skipflags do not save to the save file and will reset if the player closes the game. They are used if the player dies after viewing a long cutscene and would have to rewatch a cutscene if a skipflag was not used for it. The maximum skipflag is 64.","title":"ModCS.SkipFlag"},{"location":"api/flags/skipflag/#modcsskipflagset","text":"ModCS . SkipFlag . Set ( no ) Sets (Or \"Switches on\") the skipflag no .","title":"ModCS.SkipFlag.Set()"},{"location":"api/flags/skipflag/#modcsskipflagunset","text":"ModCS . SkipFlag . UnSet ( no ) Unsets (Or \"Switches off\") the skipflag no .","title":"ModCS.SkipFlag.Unset()"},{"location":"api/flags/skipflag/#modcsskipflagget","text":"ModCS . SkipFlag . Get ( no ) Returns true if the skipflag no is set. Returns false otherwise.","title":"ModCS.SkipFlag.Get()"},{"location":"api/objects/caret/","text":"ModCS.Caret The ModCS.Caret class represents Carets. Carets are game objects used for particles. They have no collision and draw over tiles. Unlike NPCs Carets only draw from the Caret Surface . A ModCS.Caret is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit X position of the Caret. y Pixel Unit Y position of the Caret. xm Pixel Unit X velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move() . ym Pixel Unit Y velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move() . id Caret Type ID ID of the Caret. direct Direction Direction of the NPC. This mostly does nothing by itself, but is used by different vanilla Carets as a parameter. ani_no Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. ani_wait Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. act_no Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. act_wait Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. view_x Pixel Unit X offset of the Caret sprite. view_y Pixel Unit Y offset of the Caret sprite. The Caret Buffer Spawned Carets in Cave Story are stored in a buffer (or list) of 64 entries. When the game spawns Carets it checks trough the Carets buffer and finds a spot that's not currently occupied by an alive Caret and replaces that spot with the Caret it's spawning. When the Caret in that spot dies, the spot is freed out for when the game decides to spawn another Caret again. Warning If you will be using any of the following functions for actively updating an Caret you will have to actively retrieve the Caret as well. ModCS.Caret.Spawn() ModCS . Caret . Spawn ( carettype , x , y ) Spawns a Caret of Caret Type carettype on Pixel Unit coordinates x and y . Returns a ModCS.Caret of the spawned NPC. ModCS.Caret.GetByBufferIndex() ModCS . Caret . GetByBufferIndex ( index ) Directly gets index Caret from the Caret buffer.","title":"ModCS.Caret"},{"location":"api/objects/caret/#modcscaret","text":"The ModCS.Caret class represents Carets. Carets are game objects used for particles. They have no collision and draw over tiles. Unlike NPCs Carets only draw from the Caret Surface . A ModCS.Caret is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit X position of the Caret. y Pixel Unit Y position of the Caret. xm Pixel Unit X velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move() . ym Pixel Unit Y velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move() . id Caret Type ID ID of the Caret. direct Direction Direction of the NPC. This mostly does nothing by itself, but is used by different vanilla Carets as a parameter. ani_no Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. ani_wait Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. act_no Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. act_wait Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. view_x Pixel Unit X offset of the Caret sprite. view_y Pixel Unit Y offset of the Caret sprite.","title":"ModCS.Caret"},{"location":"api/objects/caret/#the-caret-buffer","text":"Spawned Carets in Cave Story are stored in a buffer (or list) of 64 entries. When the game spawns Carets it checks trough the Carets buffer and finds a spot that's not currently occupied by an alive Caret and replaces that spot with the Caret it's spawning. When the Caret in that spot dies, the spot is freed out for when the game decides to spawn another Caret again. Warning If you will be using any of the following functions for actively updating an Caret you will have to actively retrieve the Caret as well.","title":"The Caret Buffer"},{"location":"api/objects/caret/#modcscaretspawn","text":"ModCS . Caret . Spawn ( carettype , x , y ) Spawns a Caret of Caret Type carettype on Pixel Unit coordinates x and y . Returns a ModCS.Caret of the spawned NPC.","title":"ModCS.Caret.Spawn()"},{"location":"api/objects/caret/#modcscaretgetbybufferindex","text":"ModCS . Caret . GetByBufferIndex ( index ) Directly gets index Caret from the Caret buffer.","title":"ModCS.Caret.GetByBufferIndex()"},{"location":"api/objects/direction/","text":"Direction Directions in Cave Story are represented by numbers. Value Direction 0 Left 1 Up 2 Right 3 Down 4 Auto Different objects interpret their direction parameter differently, although most of them follow this pattern. The Player and most NPCs only use the left and right directions.","title":"Direction"},{"location":"api/objects/direction/#direction","text":"Directions in Cave Story are represented by numbers. Value Direction 0 Left 1 Up 2 Right 3 Down 4 Auto Different objects interpret their direction parameter differently, although most of them follow this pattern. The Player and most NPCs only use the left and right directions.","title":"Direction"},{"location":"api/objects/npc/","text":"ModCS.Npc The ModCS.Npc class represents NPCs (Also known as Entities). NPCs are game objects used for enemies, cutscenes, enemy projectiles and (some) bosses. Examples are Toroko, First Cave Critter, Puu Black, etc. A ModCS.Npc is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit X position of the NPC. y Pixel Unit Y position of the NPC. xm Pixel Unit X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move() . ym Pixel Unit Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move() . xm2 Pixel Unit Alternative X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2() . xm2 Pixel Unit Alternative Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2() . id NPC Type ID ID of the NPC. flag Flag Flag of the NPC. event Event TSC Event of the NPC. surf Surface The surface that the NPC will draw from. hit_voice Sound ID The sound effect that will play when the NPC gets hit. destroy_voice Sound ID The sound effect that will play when the NPC dies. life Number (Casted to integer) The health points of the NPC. damage Number (Casted to integer) The amount of damage the NPC deals to the player upon touching. exp Number (Casted to integer) The XP worth of the NPC. smoke_size Number (Casted to integer) The amount of smoke the NPC will spawn after dying. Can be from 0 to 3 (0 being no smoke being spawned upon death). direct Direction Direction of the NPC. ani_no Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. ani_wait Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. act_no Number (Casted to integer) Act state value. This variable does nothing by itself, but can be changed with the <ANP TSC command. act_wait Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. pNpc NPC Parent NPC value. The NPC Buffer Spawned NPCs in Cave Story are stored in a buffer (or list) of 512 entries. Although the NPC buffer size is 512, the game starts spawning NPCs at different positions in the buffer in different places. Examples include: NPCs loaded from a PXE file start from 170. NPCs spawned by <SNP start from 256. Water splash entities start from 0. When the game spawns NPCs it checks trough the NPC buffer and finds a spot that's not currently occupied by an alive NPC and replaces that spot with the NPC it's spawning. When the NPC in that spot dies, the spot is freed out for when the game decides to spawn another NPC again. Warning If you will be using any of the following functions for actively updating an NPC you will have to actively retrieve the NPC as well. ModCS.Npc.GetByEvent() ModCS . Npc . GetByEvent ( event ) Searches the current buffer of spawned NPCs for one with an Event number event and returns a ModCS.Npc of that NPC. Returns a nil otherwise. ModCS.Npc.Spawn() ModCS . Npc . Spawn ( npctype , x , y , start_index ) Spawns an NPC of NPC Type npctype on Pixel Unit coordinates x and y . If start_index is specified the NPC buffer start position for the NPC summon will be start_index . Otherwise the NPC buffer start position will be 256. Returns a ModCS.Npc of the spawned NPC. ModCS.Npc.GetByBufferIndex() ModCS . Npc . GetByBufferIndex ( index ) Directly gets index NPC from the NPC buffer.","title":"ModCS.Npc"},{"location":"api/objects/npc/#modcsnpc","text":"The ModCS.Npc class represents NPCs (Also known as Entities). NPCs are game objects used for enemies, cutscenes, enemy projectiles and (some) bosses. Examples are Toroko, First Cave Critter, Puu Black, etc. A ModCS.Npc is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit X position of the NPC. y Pixel Unit Y position of the NPC. xm Pixel Unit X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move() . ym Pixel Unit Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move() . xm2 Pixel Unit Alternative X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2() . xm2 Pixel Unit Alternative Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2() . id NPC Type ID ID of the NPC. flag Flag Flag of the NPC. event Event TSC Event of the NPC. surf Surface The surface that the NPC will draw from. hit_voice Sound ID The sound effect that will play when the NPC gets hit. destroy_voice Sound ID The sound effect that will play when the NPC dies. life Number (Casted to integer) The health points of the NPC. damage Number (Casted to integer) The amount of damage the NPC deals to the player upon touching. exp Number (Casted to integer) The XP worth of the NPC. smoke_size Number (Casted to integer) The amount of smoke the NPC will spawn after dying. Can be from 0 to 3 (0 being no smoke being spawned upon death). direct Direction Direction of the NPC. ani_no Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. ani_wait Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. act_no Number (Casted to integer) Act state value. This variable does nothing by itself, but can be changed with the <ANP TSC command. act_wait Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. pNpc NPC Parent NPC value.","title":"ModCS.Npc"},{"location":"api/objects/npc/#the-npc-buffer","text":"Spawned NPCs in Cave Story are stored in a buffer (or list) of 512 entries. Although the NPC buffer size is 512, the game starts spawning NPCs at different positions in the buffer in different places. Examples include: NPCs loaded from a PXE file start from 170. NPCs spawned by <SNP start from 256. Water splash entities start from 0. When the game spawns NPCs it checks trough the NPC buffer and finds a spot that's not currently occupied by an alive NPC and replaces that spot with the NPC it's spawning. When the NPC in that spot dies, the spot is freed out for when the game decides to spawn another NPC again. Warning If you will be using any of the following functions for actively updating an NPC you will have to actively retrieve the NPC as well.","title":"The NPC Buffer"},{"location":"api/objects/npc/#modcsnpcgetbyevent","text":"ModCS . Npc . GetByEvent ( event ) Searches the current buffer of spawned NPCs for one with an Event number event and returns a ModCS.Npc of that NPC. Returns a nil otherwise.","title":"ModCS.Npc.GetByEvent()"},{"location":"api/objects/npc/#modcsnpcspawn","text":"ModCS . Npc . Spawn ( npctype , x , y , start_index ) Spawns an NPC of NPC Type npctype on Pixel Unit coordinates x and y . If start_index is specified the NPC buffer start position for the NPC summon will be start_index . Otherwise the NPC buffer start position will be 256. Returns a ModCS.Npc of the spawned NPC.","title":"ModCS.Npc.Spawn()"},{"location":"api/objects/npc/#modcsnpcgetbybufferindex","text":"ModCS . Npc . GetByBufferIndex ( index ) Directly gets index NPC from the NPC buffer.","title":"ModCS.Npc.GetByBufferIndex()"},{"location":"api/objects/pixel/","text":"Pixel Unit A Pixel Unit represents an in-game space coordinate. While sprites on the screen use screen coordinates, objects such as NPCs , Carets , etc. use pixel units. You may use nonintegral values as pixel units but they will always be rounded to the nearest subpixel (1/512th of a pixel).","title":"Pixel Unit"},{"location":"api/objects/pixel/#pixel-unit","text":"A Pixel Unit represents an in-game space coordinate. While sprites on the screen use screen coordinates, objects such as NPCs , Carets , etc. use pixel units. You may use nonintegral values as pixel units but they will always be rounded to the nearest subpixel (1/512th of a pixel).","title":"Pixel Unit"},{"location":"api/objects/player/","text":"ModCS.Player The ModCS.Player global object represents the player (Also known as My Character/ MYC). ModCS.Player is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit The player's X position. y Pixel Unit The player's Y position. xm Pixel Unit X velocity of the Player. ym Pixel Unit Y velocity of the Player. direct Direction The player's direction. boost_fuel Number (Casted to integer) The fuel of the Player's Booster . air Number (Casted to integer) Air value of the player. ModCS.Player.IsHit() ModCS . Player . IsHit () Returns true if the player is being hit. Returns false otherwise. ModCS.Player.IsLookingDown() ModCS . Player . IsLookingDown () Returns true if the player is looking down. Returns false otherwise. ModCS.Player.IsLookingUp() ModCS . Player . IsLookingUp () Returns true if the player is looking up. Returns false otherwise. ModCS.Player.GetLife() ModCS . Player . GetLife () Returns the player's current life points. ModCS.Player.AddLife() ModCS . Player . AddLife ( life ) Adds life to the player's life points. ModCS.Player.AddMaxLife() ModCS . Player . AddLife ( life ) Adds life to the player's max life points. ModCS.Player.Damage() ModCS . Player . Damage ( damage ) Damages the player by damage .","title":"ModCS.Player"},{"location":"api/objects/player/#modcsplayer","text":"The ModCS.Player global object represents the player (Also known as My Character/ MYC). ModCS.Player is userdata. You may access and edit the following values from it: Value Type Usage x Pixel Unit The player's X position. y Pixel Unit The player's Y position. xm Pixel Unit X velocity of the Player. ym Pixel Unit Y velocity of the Player. direct Direction The player's direction. boost_fuel Number (Casted to integer) The fuel of the Player's Booster . air Number (Casted to integer) Air value of the player.","title":"ModCS.Player"},{"location":"api/objects/player/#modcsplayerishit","text":"ModCS . Player . IsHit () Returns true if the player is being hit. Returns false otherwise.","title":"ModCS.Player.IsHit()"},{"location":"api/objects/player/#modcsplayerislookingdown","text":"ModCS . Player . IsLookingDown () Returns true if the player is looking down. Returns false otherwise.","title":"ModCS.Player.IsLookingDown()"},{"location":"api/objects/player/#modcsplayerislookingup","text":"ModCS . Player . IsLookingUp () Returns true if the player is looking up. Returns false otherwise.","title":"ModCS.Player.IsLookingUp()"},{"location":"api/objects/player/#modcsplayergetlife","text":"ModCS . Player . GetLife () Returns the player's current life points.","title":"ModCS.Player.GetLife()"},{"location":"api/objects/player/#modcsplayeraddlife","text":"ModCS . Player . AddLife ( life ) Adds life to the player's life points.","title":"ModCS.Player.AddLife()"},{"location":"api/objects/player/#modcsplayeraddmaxlife","text":"ModCS . Player . AddLife ( life ) Adds life to the player's max life points.","title":"ModCS.Player.AddMaxLife()"},{"location":"api/objects/player/#modcsplayerdamage","text":"ModCS . Player . Damage ( damage ) Damages the player by damage .","title":"ModCS.Player.Damage()"},{"location":"api/objects/range/","text":"ModCS.RangeRect The ModCS.RangeRect class represents Range Rects (Also known as Other Rects). Unlike Drawing Rects Range Rects are centered rectangles. They are used for things such as NPC hitboxes . A ModCS.Rect is userdata. You may access and edit the following values from it: Value Type Usage front Number (Casted to integer) The radius from the center to the left side of the rectangle. top Number (Casted to integer) The radius from the center to the top side of the rectangle. back Number (Casted to integer) The radius from the center to the right side of the rectangle. bottom Number (Casted to integer) The radius from the center to the bottom side of the rectangle. ModCS.RangeRect.Create() ModCS . RangeRect . Create ( front , top , back , bottom ) Returns a ModCS.RangeRect. All parameters are optional. If any parameters are given, the returned ModCS.RangeRect will use those parameters as Range Rect values. ModCS.RangeRect.Set() ModCS . RangeRect . Set ( rect , front , top , back , bottom ) Sets the ModCS.RangeRect given in the rect parameter to a ModCS.RangeRect with the following parameters.","title":"ModCS.RangeRect"},{"location":"api/objects/range/#modcsrangerect","text":"The ModCS.RangeRect class represents Range Rects (Also known as Other Rects). Unlike Drawing Rects Range Rects are centered rectangles. They are used for things such as NPC hitboxes . A ModCS.Rect is userdata. You may access and edit the following values from it: Value Type Usage front Number (Casted to integer) The radius from the center to the left side of the rectangle. top Number (Casted to integer) The radius from the center to the top side of the rectangle. back Number (Casted to integer) The radius from the center to the right side of the rectangle. bottom Number (Casted to integer) The radius from the center to the bottom side of the rectangle.","title":"ModCS.RangeRect"},{"location":"api/objects/range/#modcsrangerectcreate","text":"ModCS . RangeRect . Create ( front , top , back , bottom ) Returns a ModCS.RangeRect. All parameters are optional. If any parameters are given, the returned ModCS.RangeRect will use those parameters as Range Rect values.","title":"ModCS.RangeRect.Create()"},{"location":"api/objects/range/#modcsrangerectset","text":"ModCS . RangeRect . Set ( rect , front , top , back , bottom ) Sets the ModCS.RangeRect given in the rect parameter to a ModCS.RangeRect with the following parameters.","title":"ModCS.RangeRect.Set()"},{"location":"api/objects/caret/functions/","text":"Caret Manipulation Functions ModCS.Caret.SetRect() ModCS . Caret . SetRect ( crt , left , top , right , bottom ) ModCS . Caret . SetRect ( crt , rect ) Sets the Rect of crt to a Rect with left , top , right , bottom . If a rect is specified, set the Rect of crt to that Rect instead. ModCS.Caret.OffsetRect() ModCS . Caret . OffsetRect ( crt , left , top , right , bottom ) Adds left , top , right , bottom to the the left , top , right , bottom values of the Rect of crt . right and bottom are optional parameters. If they are not specified, left and top will be used in their place instead. ModCS.Caret.ActCode() ModCS . Caret . ActCode ( crt , carettype ) Runs the action code for Caret Type carettype to crt . Note This will run the vanilla act code for crttype . To run any overwritten act functions, run ModCS.Caret.ActX(crt) instead (where X is the Caret Type ID). ModCS.Caret.Delete() ModCS . Caret . Delete ( crt ) Deletes crt . ModCS.Caret.Move() ModCS . Caret . Move ( crt ) Adds xm and ym of crt to crt 's x and y .","title":"Caret Manipulation Functions"},{"location":"api/objects/caret/functions/#caret-manipulation-functions","text":"","title":"Caret Manipulation Functions"},{"location":"api/objects/caret/functions/#modcscaretsetrect","text":"ModCS . Caret . SetRect ( crt , left , top , right , bottom ) ModCS . Caret . SetRect ( crt , rect ) Sets the Rect of crt to a Rect with left , top , right , bottom . If a rect is specified, set the Rect of crt to that Rect instead.","title":"ModCS.Caret.SetRect()"},{"location":"api/objects/caret/functions/#modcscaretoffsetrect","text":"ModCS . Caret . OffsetRect ( crt , left , top , right , bottom ) Adds left , top , right , bottom to the the left , top , right , bottom values of the Rect of crt . right and bottom are optional parameters. If they are not specified, left and top will be used in their place instead.","title":"ModCS.Caret.OffsetRect()"},{"location":"api/objects/caret/functions/#modcscaretactcode","text":"ModCS . Caret . ActCode ( crt , carettype ) Runs the action code for Caret Type carettype to crt . Note This will run the vanilla act code for crttype . To run any overwritten act functions, run ModCS.Caret.ActX(crt) instead (where X is the Caret Type ID).","title":"ModCS.Caret.ActCode()"},{"location":"api/objects/caret/functions/#modcscaretdelete","text":"ModCS . Caret . Delete ( crt ) Deletes crt .","title":"ModCS.Caret.Delete()"},{"location":"api/objects/caret/functions/#modcscaretmove","text":"ModCS . Caret . Move ( crt ) Adds xm and ym of crt to crt 's x and y .","title":"ModCS.Caret.Move()"},{"location":"api/objects/caret/id/","text":"Caret Type IDs A Caret Type ID (Also known as Act ID or character code) is a number that defines an Caret's type. Caret Table A table of default Caret sprite offsets are stored in a caret.tbl file in the data folder. When Carets of a set type are spawned they will initially use sprite offsets from their Caret Table entry, although these offsets can be changed for Carets with scripting at any time. Caret Type reference Caret Type ID Caret 0 Null 1 Bubble 2 Projectile dissipation 3 Shoot Particle 4 Snake Afterimage (Unused) 5 Zzz Sleeping Particles 6 Snake Afterimage (Duplicate) 7 Booster Particle 8 Drowned Player 9 Interact Question mark 10 'Level Up!' 11 Red hurt particles 12 Explosion flash 13 White circle particles (Used by Demon Crown and when the player bumps onto a ceiling) 14 Broken caret 15 Small projectile dissipation 16 'Empty!' 17 'PUSH JUMP KEY!' (Unused) Overriding Carets ModCS allows you to override a Caret type's act code. If a function ModCS.Caret.ActX (where X is the Caret Type ID of the Caret Type you want to override) is defined in your Lua script the game will run that function instead of the built-in Caret act code. A ModCS.Caret will be passed as the first argument of the function when it's called. Example This example will set the Rect of Caret Type 1 to 0,0,8,8. 1 2 3 function ModCS . Caret . Act1 ( crt ) crt : SetRect ( 0 , 0 , 8 , 8 ) end","title":"Caret Type IDs"},{"location":"api/objects/caret/id/#caret-type-ids","text":"A Caret Type ID (Also known as Act ID or character code) is a number that defines an Caret's type.","title":"Caret Type IDs"},{"location":"api/objects/caret/id/#caret-table","text":"A table of default Caret sprite offsets are stored in a caret.tbl file in the data folder. When Carets of a set type are spawned they will initially use sprite offsets from their Caret Table entry, although these offsets can be changed for Carets with scripting at any time.","title":"Caret Table"},{"location":"api/objects/caret/id/#caret-type-reference","text":"Caret Type ID Caret 0 Null 1 Bubble 2 Projectile dissipation 3 Shoot Particle 4 Snake Afterimage (Unused) 5 Zzz Sleeping Particles 6 Snake Afterimage (Duplicate) 7 Booster Particle 8 Drowned Player 9 Interact Question mark 10 'Level Up!' 11 Red hurt particles 12 Explosion flash 13 White circle particles (Used by Demon Crown and when the player bumps onto a ceiling) 14 Broken caret 15 Small projectile dissipation 16 'Empty!' 17 'PUSH JUMP KEY!' (Unused)","title":"Caret Type reference"},{"location":"api/objects/caret/id/#overriding-carets","text":"ModCS allows you to override a Caret type's act code. If a function ModCS.Caret.ActX (where X is the Caret Type ID of the Caret Type you want to override) is defined in your Lua script the game will run that function instead of the built-in Caret act code. A ModCS.Caret will be passed as the first argument of the function when it's called. Example This example will set the Rect of Caret Type 1 to 0,0,8,8. 1 2 3 function ModCS . Caret . Act1 ( crt ) crt : SetRect ( 0 , 0 , 8 , 8 ) end","title":"Overriding Carets"},{"location":"api/objects/npc/bits/","text":"NPC Bits NPC Bits (Also known as NPC Flags) are toggles on NPCs that enable certain NPC features. They can be turned on for individual NPC Types as well as for individual NPCs in a PXE file. Note In the original game NPC Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values. Value Bitwise Value Usage 0 0x0001 Collision against player - Pushes player out. 1 0x0002 Ignore tile attribute 44. 2 0x0004 Cannot be hurt and has a different hit effect when hit by a bullet. 3 0x0008 Ignore tile collision. 4 0x0010 The top of the NPC is bouncy. 5 0x0020 The NPC is shootable. 6 0x0040 Collision against player. 7 0x0080 Rear and top of the NPC does not hurt the player. 8 0x0100 The TSC Event specified in the event parameter of the ModCS.Npc will run when the player touches the NPC. 9 0x0200 The TSC Event specified in the event parameter of the ModCS.Npc will run when the NPC dies. 11 0x0800 The NPC will not spawn unless the Flag specified in the flag parameter of ModCS.Npc is set. 12 0x1000 The NPC will spawn with the direct parameter of the ModCS.Npc being set to 2. 13 0x2000 If the player interacts with the NPC the TSC Event specified in the event parameter of the ModCS.Npc will run. 14 0x4000 The NPC will not spawn if the Flag specified in the flag parameter of ModCS.Npc is set. 15 0x8000 Damage dealt to the NPC will show in a damage indicator. ModCS.Npc.SetBit() ModCS . Npc . SetBit ( npc , bit ) Sets the bit bit for npc . ModCS.Npc.UnsetBit() ModCS . Npc . UnsetBit ( npc , bit ) Unsets the bit bit for npc . ModCS.Npc.CheckBit() ModCS . Npc . CheckBit ( npc , bit ) Returns true if the bit bit for npc is set. Returns false otherwise.","title":"NPC Bits"},{"location":"api/objects/npc/bits/#npc-bits","text":"NPC Bits (Also known as NPC Flags) are toggles on NPCs that enable certain NPC features. They can be turned on for individual NPC Types as well as for individual NPCs in a PXE file. Note In the original game NPC Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values. Value Bitwise Value Usage 0 0x0001 Collision against player - Pushes player out. 1 0x0002 Ignore tile attribute 44. 2 0x0004 Cannot be hurt and has a different hit effect when hit by a bullet. 3 0x0008 Ignore tile collision. 4 0x0010 The top of the NPC is bouncy. 5 0x0020 The NPC is shootable. 6 0x0040 Collision against player. 7 0x0080 Rear and top of the NPC does not hurt the player. 8 0x0100 The TSC Event specified in the event parameter of the ModCS.Npc will run when the player touches the NPC. 9 0x0200 The TSC Event specified in the event parameter of the ModCS.Npc will run when the NPC dies. 11 0x0800 The NPC will not spawn unless the Flag specified in the flag parameter of ModCS.Npc is set. 12 0x1000 The NPC will spawn with the direct parameter of the ModCS.Npc being set to 2. 13 0x2000 If the player interacts with the NPC the TSC Event specified in the event parameter of the ModCS.Npc will run. 14 0x4000 The NPC will not spawn if the Flag specified in the flag parameter of ModCS.Npc is set. 15 0x8000 Damage dealt to the NPC will show in a damage indicator.","title":"NPC Bits"},{"location":"api/objects/npc/bits/#modcsnpcsetbit","text":"ModCS . Npc . SetBit ( npc , bit ) Sets the bit bit for npc .","title":"ModCS.Npc.SetBit()"},{"location":"api/objects/npc/bits/#modcsnpcunsetbit","text":"ModCS . Npc . UnsetBit ( npc , bit ) Unsets the bit bit for npc .","title":"ModCS.Npc.UnsetBit()"},{"location":"api/objects/npc/bits/#modcsnpccheckbit","text":"ModCS . Npc . CheckBit ( npc , bit ) Returns true if the bit bit for npc is set. Returns false otherwise.","title":"ModCS.Npc.CheckBit()"},{"location":"api/objects/npc/collision/","text":"NPC Collision detection ModCS.Npc.TouchLeftWall() ModCS . Npc . TouchLeftWall ( npc ) Returns true if npc is touching a left wall. ModCS.Npc.TouchRightWall() ModCS . Npc . TouchRightWall ( npc ) Returns true if npc is touching a right wall. ModCS.Npc.TouchCeiling() ModCS . Npc . TouchCeiling ( npc ) Returns true if npc is touching a ceiling. ModCS.Npc.TouchFloor() ModCS . Npc . TouchFloor ( npc ) Returns true if npc is touching a floor. ModCS.Npc.TouchSlopeRight() ModCS . Npc . TouchSlopeRight ( npc ) Returns true if npc is touching a right slope. ModCS.Npc.TouchSlopeLeft() ModCS . Npc . TouchSlopeLeft ( npc ) Returns true if npc is touching a left slope. ModCS.Npc.TouchTile() ModCS . Npc . TouchTile ( npc ) Returns true if npc is touching any type of collision tile. ModCS.Npc.TouchPlayer() ModCS . Npc . TouchPlayer ( npc ) Returns true if npc is touching the player.","title":"NPC Collision detection"},{"location":"api/objects/npc/collision/#npc-collision-detection","text":"","title":"NPC Collision detection"},{"location":"api/objects/npc/collision/#modcsnpctouchleftwall","text":"ModCS . Npc . TouchLeftWall ( npc ) Returns true if npc is touching a left wall.","title":"ModCS.Npc.TouchLeftWall()"},{"location":"api/objects/npc/collision/#modcsnpctouchrightwall","text":"ModCS . Npc . TouchRightWall ( npc ) Returns true if npc is touching a right wall.","title":"ModCS.Npc.TouchRightWall()"},{"location":"api/objects/npc/collision/#modcsnpctouchceiling","text":"ModCS . Npc . TouchCeiling ( npc ) Returns true if npc is touching a ceiling.","title":"ModCS.Npc.TouchCeiling()"},{"location":"api/objects/npc/collision/#modcsnpctouchfloor","text":"ModCS . Npc . TouchFloor ( npc ) Returns true if npc is touching a floor.","title":"ModCS.Npc.TouchFloor()"},{"location":"api/objects/npc/collision/#modcsnpctouchsloperight","text":"ModCS . Npc . TouchSlopeRight ( npc ) Returns true if npc is touching a right slope.","title":"ModCS.Npc.TouchSlopeRight()"},{"location":"api/objects/npc/collision/#modcsnpctouchslopeleft","text":"ModCS . Npc . TouchSlopeLeft ( npc ) Returns true if npc is touching a left slope.","title":"ModCS.Npc.TouchSlopeLeft()"},{"location":"api/objects/npc/collision/#modcsnpctouchtile","text":"ModCS . Npc . TouchTile ( npc ) Returns true if npc is touching any type of collision tile.","title":"ModCS.Npc.TouchTile()"},{"location":"api/objects/npc/collision/#modcsnpctouchplayer","text":"ModCS . Npc . TouchPlayer ( npc ) Returns true if npc is touching the player.","title":"ModCS.Npc.TouchPlayer()"},{"location":"api/objects/npc/functions/","text":"NPC Manipulation Functions ModCS.Npc.SetRect() ModCS . Npc . SetRect ( npc , left , top , right , bottom ) ModCS . Npc . SetRect ( npc , rect ) Sets the Rect of npc to a Rect with left , top , right , bottom . If a rect is specified, set the Rect of npc to that Rect instead. ModCS.Npc.OffsetRect() ModCS . Npc . OffsetRect ( npc , left , top , right , bottom ) Adds left , top , right , bottom to the the left , top , right , bottom values of the Rect of npc . right and bottom are optional parameters. If they are not specified, left and top will be used in their place instead. ModCS.Npc.SetHitbox() ModCS . Npc . SetHitbox ( npc , front , top , back , bottom ) ModCS . Npc . SetHitbox ( npc , rangerect ) Sets the hitbox of npc to a RangeRect with front , top , back , bottom . If a rangerect is specified, set the hitbox of npc to that RangeRect instead. Warning When editing NPC hitboxes make sure that the front and back values of the hitbox are the same, otherwise you might get weird hitbox behavior. ModCS.Npc.SetViewbox() ModCS . Npc . SetViewbox ( npc , front , top , back , bottom ) ModCS . Npc . SetViewbox ( npc , rangerect ) Sets the sprite offset of npc to a RangeRect with front , top , back , bottom . If a rangerect is specified, set the sprite offset of npc to that RangeRect instead. ModCS.Npc.ActCode() ModCS . Npc . ActCode ( npc , npctype ) Runs the action code for NPC Type npctype to npc . Note This will run the vanilla act code for npctype . To run any overwritten act functions, run ModCS.Npc.ActX(npc) instead (where X is the NPC Type ID). ModCS.Npc.IsHit() ModCS . Npc . IsHit ( npc ) Returns true if npc is being hit by a bullet. Returns false otherwise. ModCS.Npc.Delete() ModCS . Npc . Delete ( npc ) Deletes npc . Same effect as <DNP . ModCS.Npc.Kill() ModCS . Npc . Kill ( npc ) Kills npc . ModCS.Npc.KillOnNextFrame() ModCS . Npc . KillOnNextFrame ( npc ) Sets npc for deletion on the next frame. ModCS.Npc.Move() ModCS . Npc . Move ( npc ) Adds xm and ym of npc to npc 's x and y . ModCS.Npc.Move2() ModCS . Npc . Move2 ( npc ) Adds xm2 and ym2 of npc to npc 's x and y .","title":"NPC Manipulation Functions"},{"location":"api/objects/npc/functions/#npc-manipulation-functions","text":"","title":"NPC Manipulation Functions"},{"location":"api/objects/npc/functions/#modcsnpcsetrect","text":"ModCS . Npc . SetRect ( npc , left , top , right , bottom ) ModCS . Npc . SetRect ( npc , rect ) Sets the Rect of npc to a Rect with left , top , right , bottom . If a rect is specified, set the Rect of npc to that Rect instead.","title":"ModCS.Npc.SetRect()"},{"location":"api/objects/npc/functions/#modcsnpcoffsetrect","text":"ModCS . Npc . OffsetRect ( npc , left , top , right , bottom ) Adds left , top , right , bottom to the the left , top , right , bottom values of the Rect of npc . right and bottom are optional parameters. If they are not specified, left and top will be used in their place instead.","title":"ModCS.Npc.OffsetRect()"},{"location":"api/objects/npc/functions/#modcsnpcsethitbox","text":"ModCS . Npc . SetHitbox ( npc , front , top , back , bottom ) ModCS . Npc . SetHitbox ( npc , rangerect ) Sets the hitbox of npc to a RangeRect with front , top , back , bottom . If a rangerect is specified, set the hitbox of npc to that RangeRect instead. Warning When editing NPC hitboxes make sure that the front and back values of the hitbox are the same, otherwise you might get weird hitbox behavior.","title":"ModCS.Npc.SetHitbox()"},{"location":"api/objects/npc/functions/#modcsnpcsetviewbox","text":"ModCS . Npc . SetViewbox ( npc , front , top , back , bottom ) ModCS . Npc . SetViewbox ( npc , rangerect ) Sets the sprite offset of npc to a RangeRect with front , top , back , bottom . If a rangerect is specified, set the sprite offset of npc to that RangeRect instead.","title":"ModCS.Npc.SetViewbox()"},{"location":"api/objects/npc/functions/#modcsnpcactcode","text":"ModCS . Npc . ActCode ( npc , npctype ) Runs the action code for NPC Type npctype to npc . Note This will run the vanilla act code for npctype . To run any overwritten act functions, run ModCS.Npc.ActX(npc) instead (where X is the NPC Type ID).","title":"ModCS.Npc.ActCode()"},{"location":"api/objects/npc/functions/#modcsnpcishit","text":"ModCS . Npc . IsHit ( npc ) Returns true if npc is being hit by a bullet. Returns false otherwise.","title":"ModCS.Npc.IsHit()"},{"location":"api/objects/npc/functions/#modcsnpcdelete","text":"ModCS . Npc . Delete ( npc ) Deletes npc . Same effect as <DNP .","title":"ModCS.Npc.Delete()"},{"location":"api/objects/npc/functions/#modcsnpckill","text":"ModCS . Npc . Kill ( npc ) Kills npc .","title":"ModCS.Npc.Kill()"},{"location":"api/objects/npc/functions/#modcsnpckillonnextframe","text":"ModCS . Npc . KillOnNextFrame ( npc ) Sets npc for deletion on the next frame.","title":"ModCS.Npc.KillOnNextFrame()"},{"location":"api/objects/npc/functions/#modcsnpcmove","text":"ModCS . Npc . Move ( npc ) Adds xm and ym of npc to npc 's x and y .","title":"ModCS.Npc.Move()"},{"location":"api/objects/npc/functions/#modcsnpcmove2","text":"ModCS . Npc . Move2 ( npc ) Adds xm2 and ym2 of npc to npc 's x and y .","title":"ModCS.Npc.Move2()"},{"location":"api/objects/npc/id/","text":"NPC Type IDs An NPC Type ID (Also known as Act ID or character code) is a number that defines an NPC's type. NPC Table A table of default NPC properties are stored in a npc.tbl file in the data folder. You may edit this table with your favorite Cave Story editor. When NPCs of a set type are spawned they will initially use properties from their NPC Table entry, although these properties can be changed for NPCs with scripting at any time. Note Some vanilla NPCs change their damage or other features gotten from the NPC Table dynamically. Changing the NPC Table properties on these NPCs will most likely have little effect. NPC Table parameters on different editors Different Cave Story editors use different terminology on NPC Table parameters. This section translates all of them to ModCS API equivalents. Booster's Lab The King's Table Cave Editor life parameter of a ModCS.Npc damage parameter of a ModCS.Npc exp parameter of a ModCS.Npc NPC Bits NPC Hitbox NPC Viewbox surf parameter of a ModCS.Npc hit_voice parameter of a ModCS.Npc destroy_voice parameter of a ModCS.Npc smoke_size parameter of a ModCS.Npc NPC Type reference ... Here I would put my own NPC Type reference table but I'm currently too lazy. Please refer to your map editor's NPC list or this Cave Story NPC Spreadsheet instead. Overriding NPCs ModCS allows you to override an NPC type's act code. If a function ModCS.Npc.ActX (where X is the NPC Type ID of the NPC Type you want to override) is defined in your Lua script the game will run that function instead of the built-in NPC act code. A ModCS.Npc will be passed as the first argument of the function when it's called. Example This example will set the Rect of NPC Type 0 (The Null NPC) to 16,0,32,16. 1 2 3 function ModCS . Npc . Act0 ( npc ) npc : SetRect ( 16 , 0 , 32 , 16 ) end","title":"NPC Type IDs"},{"location":"api/objects/npc/id/#npc-type-ids","text":"An NPC Type ID (Also known as Act ID or character code) is a number that defines an NPC's type.","title":"NPC Type IDs"},{"location":"api/objects/npc/id/#npc-table","text":"A table of default NPC properties are stored in a npc.tbl file in the data folder. You may edit this table with your favorite Cave Story editor. When NPCs of a set type are spawned they will initially use properties from their NPC Table entry, although these properties can be changed for NPCs with scripting at any time. Note Some vanilla NPCs change their damage or other features gotten from the NPC Table dynamically. Changing the NPC Table properties on these NPCs will most likely have little effect. NPC Table parameters on different editors Different Cave Story editors use different terminology on NPC Table parameters. This section translates all of them to ModCS API equivalents. Booster's Lab The King's Table Cave Editor life parameter of a ModCS.Npc damage parameter of a ModCS.Npc exp parameter of a ModCS.Npc NPC Bits NPC Hitbox NPC Viewbox surf parameter of a ModCS.Npc hit_voice parameter of a ModCS.Npc destroy_voice parameter of a ModCS.Npc smoke_size parameter of a ModCS.Npc","title":"NPC Table"},{"location":"api/objects/npc/id/#npc-type-reference","text":"... Here I would put my own NPC Type reference table but I'm currently too lazy. Please refer to your map editor's NPC list or this Cave Story NPC Spreadsheet instead.","title":"NPC Type reference"},{"location":"api/objects/npc/id/#overriding-npcs","text":"ModCS allows you to override an NPC type's act code. If a function ModCS.Npc.ActX (where X is the NPC Type ID of the NPC Type you want to override) is defined in your Lua script the game will run that function instead of the built-in NPC act code. A ModCS.Npc will be passed as the first argument of the function when it's called. Example This example will set the Rect of NPC Type 0 (The Null NPC) to 16,0,32,16. 1 2 3 function ModCS . Npc . Act0 ( npc ) npc : SetRect ( 16 , 0 , 32 , 16 ) end","title":"Overriding NPCs"},{"location":"api/objects/player/collision/","text":"Player Collision detection ModCS.Player.TouchLeftWall() ModCS . Player . TouchLeftWall () Returns true if the player is touching a left wall. ModCS.Player.TouchRightWall() ModCS . Player . TouchRightWall () Returns true if the player is touching a right wall. ModCS.Player.TouchCeiling() ModCS . Player . TouchCeiling () Returns true if the player is touching a ceiling. ModCS.Player.TouchFloor() ModCS . Player . TouchFloor () Returns true if the player is touching a floor. ModCS.Player.TouchSlopeRight() ModCS . Player . TouchSlopeRight () Returns true if the player is touching a right slope. ModCS.Player.TouchSlopeLeft() ModCS . Player . TouchSlopeLeft () Returns true if the player is touching a left slope. ModCS.Player.TouchTile() ModCS . Player . TouchTile () Returns true if the player is touching any type of collision tile.","title":"Player Collision detection"},{"location":"api/objects/player/collision/#player-collision-detection","text":"","title":"Player Collision detection"},{"location":"api/objects/player/collision/#modcsplayertouchleftwall","text":"ModCS . Player . TouchLeftWall () Returns true if the player is touching a left wall.","title":"ModCS.Player.TouchLeftWall()"},{"location":"api/objects/player/collision/#modcsplayertouchrightwall","text":"ModCS . Player . TouchRightWall () Returns true if the player is touching a right wall.","title":"ModCS.Player.TouchRightWall()"},{"location":"api/objects/player/collision/#modcsplayertouchceiling","text":"ModCS . Player . TouchCeiling () Returns true if the player is touching a ceiling.","title":"ModCS.Player.TouchCeiling()"},{"location":"api/objects/player/collision/#modcsplayertouchfloor","text":"ModCS . Player . TouchFloor () Returns true if the player is touching a floor.","title":"ModCS.Player.TouchFloor()"},{"location":"api/objects/player/collision/#modcsplayertouchsloperight","text":"ModCS . Player . TouchSlopeRight () Returns true if the player is touching a right slope.","title":"ModCS.Player.TouchSlopeRight()"},{"location":"api/objects/player/collision/#modcsplayertouchslopeleft","text":"ModCS . Player . TouchSlopeLeft () Returns true if the player is touching a left slope.","title":"ModCS.Player.TouchSlopeLeft()"},{"location":"api/objects/player/collision/#modcsplayertouchtile","text":"ModCS . Player . TouchTile () Returns true if the player is touching any type of collision tile.","title":"ModCS.Player.TouchTile()"},{"location":"api/objects/player/equip/","text":"Player Equip Player Equip Values are toggles that enable certain features for the player. They are mostly used in Cave Story for checking equipped items. Note In the original game and TSC equip values are bit-wise. For simplicity's sake ModCS uses normal decimal values. Value Bitwise Value Usage 0 0x0001 Booster v0.8 (Ignored if v2.0 is equipped) 1 0x0002 Map System 2 0x0004 Arms Barrier 3 0x0008 Turbocharge 4 0x0010 Air Tank 5 0x0020 Booster v2.0 6 0x0040 Mimiga Mask 7 0x0080 Whimsical Star 8 0x0100 Nikumaru Counter ModCS.Player.Equip() ModCS . Player . Equip ( value ) Sets the equip value value . ModCS.Player.Equip() ModCS . Player . Unequip ( value ) Unsets the equip value value . ModCS.Player.HasEquipped() ModCS . Player . HasEquipped ( value ) Returns true if the equip value value is set. Returns false otherwise.","title":"Player Equip"},{"location":"api/objects/player/equip/#player-equip","text":"Player Equip Values are toggles that enable certain features for the player. They are mostly used in Cave Story for checking equipped items. Note In the original game and TSC equip values are bit-wise. For simplicity's sake ModCS uses normal decimal values. Value Bitwise Value Usage 0 0x0001 Booster v0.8 (Ignored if v2.0 is equipped) 1 0x0002 Map System 2 0x0004 Arms Barrier 3 0x0008 Turbocharge 4 0x0010 Air Tank 5 0x0020 Booster v2.0 6 0x0040 Mimiga Mask 7 0x0080 Whimsical Star 8 0x0100 Nikumaru Counter","title":"Player Equip"},{"location":"api/objects/player/equip/#modcsplayerequip","text":"ModCS . Player . Equip ( value ) Sets the equip value value .","title":"ModCS.Player.Equip()"},{"location":"api/objects/player/equip/#modcsplayerequip_1","text":"ModCS . Player . Unequip ( value ) Unsets the equip value value .","title":"ModCS.Player.Equip()"},{"location":"api/objects/player/equip/#modcsplayerhasequipped","text":"ModCS . Player . HasEquipped ( value ) Returns true if the equip value value is set. Returns false otherwise.","title":"ModCS.Player.HasEquipped()"},{"location":"api/sound/organya/","text":"ModCS.Organya The ModCS.Organya namespace contains functions related to playing Organya music. Music ID reference Music ID Name Internal Name 0 None XXXX 1 Mischievous Robot WANPAKU 2 Safety ANZEN 3 Game Over GAMEOVER 4 Gravity GRAVITY 5 On To Grasstown WEED 6 Meltdown 2 MDOWN2 7 Eyes of Flame FIREEYE 8 Gestation VIVI 9 Mimiga Town MURA 10 Get Item FANFALE1 11 Balrog's Theme GINSUKE 12 Cemetery CEMETERY 13 Plant PLANT 14 Pulse KODOU 15 Victory FANFALE3 16 Get Life Capsule FANFALE2 17 Tyrant DR 18 Run ESCAPE 19 Jenka 1 JENKA 20 Labyrinth Fight MAZE 21 Access ACCESS 22 Oppression IRONH 23 Geothermal GRAND 24 Cave Story CURLY 25 Moonsong OSIDE 26 Hero's End REQUIEM 27 Scorching Back WANPAK2 28 Quiet QUIET 29 Final Cave LASTCAVE 30 Balcony BALCONY 31 Charge LASTBTL 32 Last Battle LASTBT3 33 The Way Back Home ENDING 34 Zombie ZONBIE 35 Break Down BDOWN 36 Running Hell HELL 37 Jenka 2 JENKA2 38 Living Waterway MARINE 39 Seal Chamber BALLOS 40 Toroko's Theme TOROKO 41 White Stone Wall WHITE ModCS.Organya.Play() ModCS . Organya . Play ( id ) Changes the current music playing to music id .","title":"ModCS.Organya"},{"location":"api/sound/organya/#modcsorganya","text":"The ModCS.Organya namespace contains functions related to playing Organya music.","title":"ModCS.Organya"},{"location":"api/sound/organya/#music-id-reference","text":"Music ID Name Internal Name 0 None XXXX 1 Mischievous Robot WANPAKU 2 Safety ANZEN 3 Game Over GAMEOVER 4 Gravity GRAVITY 5 On To Grasstown WEED 6 Meltdown 2 MDOWN2 7 Eyes of Flame FIREEYE 8 Gestation VIVI 9 Mimiga Town MURA 10 Get Item FANFALE1 11 Balrog's Theme GINSUKE 12 Cemetery CEMETERY 13 Plant PLANT 14 Pulse KODOU 15 Victory FANFALE3 16 Get Life Capsule FANFALE2 17 Tyrant DR 18 Run ESCAPE 19 Jenka 1 JENKA 20 Labyrinth Fight MAZE 21 Access ACCESS 22 Oppression IRONH 23 Geothermal GRAND 24 Cave Story CURLY 25 Moonsong OSIDE 26 Hero's End REQUIEM 27 Scorching Back WANPAK2 28 Quiet QUIET 29 Final Cave LASTCAVE 30 Balcony BALCONY 31 Charge LASTBTL 32 Last Battle LASTBT3 33 The Way Back Home ENDING 34 Zombie ZONBIE 35 Break Down BDOWN 36 Running Hell HELL 37 Jenka 2 JENKA2 38 Living Waterway MARINE 39 Seal Chamber BALLOS 40 Toroko's Theme TOROKO 41 White Stone Wall WHITE","title":"Music ID reference"},{"location":"api/sound/organya/#modcsorganyaplay","text":"ModCS . Organya . Play ( id ) Changes the current music playing to music id .","title":"ModCS.Organya.Play()"},{"location":"api/sound/sound/","text":"ModCS.Sound The ModCS.Sound namespace contains functions related to playing different sound effects. Sound Effects ID reference ... Here I would put my own sound effects table but I'm currently too lazy. Please refer to your map editor's sound effects list. ModCS.Sound.Play() ModCS . Sound . Play ( id , loop ) Plays sound effect id . loop is an optional parameter and a Boolean. If set to true the given sound effect will play on loop. ModCS.Sound.Stop() ModCS . Npc . Stop ( id ) Stop playing sound effect id .","title":"ModCS.Sound"},{"location":"api/sound/sound/#modcssound","text":"The ModCS.Sound namespace contains functions related to playing different sound effects.","title":"ModCS.Sound"},{"location":"api/sound/sound/#sound-effects-id-reference","text":"... Here I would put my own sound effects table but I'm currently too lazy. Please refer to your map editor's sound effects list.","title":"Sound Effects ID reference"},{"location":"api/sound/sound/#modcssoundplay","text":"ModCS . Sound . Play ( id , loop ) Plays sound effect id . loop is an optional parameter and a Boolean. If set to true the given sound effect will play on loop.","title":"ModCS.Sound.Play()"},{"location":"api/sound/sound/#modcssoundstop","text":"ModCS . Npc . Stop ( id ) Stop playing sound effect id .","title":"ModCS.Sound.Stop()"},{"location":"guide/basics/","text":"1 - Basics After you've downloaded ModCS and launched your editor of choice, it's time to start making your mod. To open your mod in an editor go to File -> Load and navigate to your Mod's data folder . There load stage.tbl . Note The King's Table uses a different system for loading mods. You will have to open your stage.tbl file from File -> New. Afterwards, press File -> Save Project to save a The King's Table project file for your mod. Any time you want to load your mod afterwards press File -> Load and open your project file. Loading Different Engines You will have to load different things for different Cave Story engines. For CSE2 Enhanced you may load a mrmap.bin . For Freeware modding you will have to load your mod EXE. If you will be modding freeware it's very important to press File -> Save All right after you have loaded your EXE.","title":"1 - Basics"},{"location":"guide/basics/#1-basics","text":"After you've downloaded ModCS and launched your editor of choice, it's time to start making your mod. To open your mod in an editor go to File -> Load and navigate to your Mod's data folder . There load stage.tbl . Note The King's Table uses a different system for loading mods. You will have to open your stage.tbl file from File -> New. Afterwards, press File -> Save Project to save a The King's Table project file for your mod. Any time you want to load your mod afterwards press File -> Load and open your project file. Loading Different Engines You will have to load different things for different Cave Story engines. For CSE2 Enhanced you may load a mrmap.bin . For Freeware modding you will have to load your mod EXE. If you will be modding freeware it's very important to press File -> Save All right after you have loaded your EXE.","title":"1 - Basics"},{"location":"guide/intro/","text":"0 - Introduction ModCS is a Cave Story modding utility, which's main feature is Lua Scripting . This modding guide will go over the basics of Cave Story modding before going into scripting. Although this guide's main purpose was for ModCS, it will contain extra information about differences in modding between different engines, so if you are new to modding this guide may be a good introduction for any type of engine (Original Freeware EXE, CSE2, etc.) until the Scripting Section , which will exclusively focus on ModCS's Lua Scripting. If you are having any trouble with anything unrelated to Lua scripting there are a couple of places you may ask for help, such as the Cave Story Modding Community or the Cave Story Tribute Site Forums .","title":"0 - Introduction"},{"location":"guide/intro/#0-introduction","text":"ModCS is a Cave Story modding utility, which's main feature is Lua Scripting . This modding guide will go over the basics of Cave Story modding before going into scripting. Although this guide's main purpose was for ModCS, it will contain extra information about differences in modding between different engines, so if you are new to modding this guide may be a good introduction for any type of engine (Original Freeware EXE, CSE2, etc.) until the Scripting Section , which will exclusively focus on ModCS's Lua Scripting. If you are having any trouble with anything unrelated to Lua scripting there are a couple of places you may ask for help, such as the Cave Story Modding Community or the Cave Story Tribute Site Forums .","title":"0 - Introduction"},{"location":"guide/lua/","text":"3 - Lua Scripting The main feature of ModCS is its Lua Scripting API , which allows for advanced Cave Story modifications without the use of Assembly or C. Currently the API has enough features for modifying HUD, advanced modifying of NPCs, making NPCs and custom TSC commands. This chapter of the guide will go over basic usage of the drawing and NPC APIs. By the end of this guide you should be able to: Make custom HUD elements. Modify sprites of already existing NPCs. Make custom NPCs and enemies from scratch. Lua is an incredibly easy scripting language to learn and during the course of this guide it's assumed that the reader will be learn it on the go. This is not a general Lua scripting guide, but if you are struggling with keeping up you may want to check out this Lua tutorial .","title":"3 - Lua Scripting"},{"location":"guide/lua/#3-lua-scripting","text":"The main feature of ModCS is its Lua Scripting API , which allows for advanced Cave Story modifications without the use of Assembly or C. Currently the API has enough features for modifying HUD, advanced modifying of NPCs, making NPCs and custom TSC commands. This chapter of the guide will go over basic usage of the drawing and NPC APIs. By the end of this guide you should be able to: Make custom HUD elements. Modify sprites of already existing NPCs. Make custom NPCs and enemies from scratch. Lua is an incredibly easy scripting language to learn and during the course of this guide it's assumed that the reader will be learn it on the go. This is not a general Lua scripting guide, but if you are struggling with keeping up you may want to check out this Lua tutorial .","title":"3 - Lua Scripting"},{"location":"guide/tsc/","text":"2 - Text Scripting Text Script (Also known as TSC or T-Script) are the primary way to create and cause things to happen in your stage. TSC's abilities include displaying dialogue, controlling NPCs and making them perform specific actions, giving the player items, or modifying the tiles of your stage on the fly. A typical text script for a stage looks like this: #0101 <CMD... <CMD... <CMD... <END #0102 <CMD... <CMD... <CMD... <END #0103 <CMD... <CMD... <CMD... <END The preceding # represents a four-digit Event ID , and everything following it are Commands that are run when that particular event occurs, up until the <END . Commands in TSC begin with a < and always have three character names, such as <MSG or <WAI . A TSC command can also have additional numbers following it as parameters that affect its operation, like the following: <AM+0002:0000 Here, two parameters are passed to the command <AM+ : 2 and 0 . Parameters are padded with zeros to be exactly four digits long, and are separated by colons. The longest TSC commands can have four parameters, although many have none or only one. In addition to text scripts specific to a given Stage , all Stages automatically share a script contained in data/Head.tsc . In vanilla Cave Story, this contains several events that are used throughout the game, like the \"Do you want to save?\" prompt or \"You have died.\" These always take up the lowest event IDs, so it is generally good practice to start labelling your own events at #0090 or #0100 .","title":"2 - Text Scripting"},{"location":"guide/tsc/#2-text-scripting","text":"Text Script (Also known as TSC or T-Script) are the primary way to create and cause things to happen in your stage. TSC's abilities include displaying dialogue, controlling NPCs and making them perform specific actions, giving the player items, or modifying the tiles of your stage on the fly. A typical text script for a stage looks like this: #0101 <CMD... <CMD... <CMD... <END #0102 <CMD... <CMD... <CMD... <END #0103 <CMD... <CMD... <CMD... <END The preceding # represents a four-digit Event ID , and everything following it are Commands that are run when that particular event occurs, up until the <END . Commands in TSC begin with a < and always have three character names, such as <MSG or <WAI . A TSC command can also have additional numbers following it as parameters that affect its operation, like the following: <AM+0002:0000 Here, two parameters are passed to the command <AM+ : 2 and 0 . Parameters are padded with zeros to be exactly four digits long, and are separated by colons. The longest TSC commands can have four parameters, although many have none or only one. In addition to text scripts specific to a given Stage , all Stages automatically share a script contained in data/Head.tsc . In vanilla Cave Story, this contains several events that are used throughout the game, like the \"Do you want to save?\" prompt or \"You have died.\" These always take up the lowest event IDs, so it is generally good practice to start labelling your own events at #0090 or #0100 .","title":"2 - Text Scripting"},{"location":"guide/basics/bgs/","text":"1.4 - Backgrounds Backgrounds are stored in the data folder as .bmp files with a Bk prefix (Example: BkBlue.bmp ). They are choosen per stage therefore are loaded from a Stage Table entry parameter. The other Stage Table entry parameter related to backgrounds is \"Scroll Type\" and it determines the background's scroll type.","title":"1.4 - Backgrounds"},{"location":"guide/basics/bgs/#14-backgrounds","text":"Backgrounds are stored in the data folder as .bmp files with a Bk prefix (Example: BkBlue.bmp ). They are choosen per stage therefore are loaded from a Stage Table entry parameter. The other Stage Table entry parameter related to backgrounds is \"Scroll Type\" and it determines the background's scroll type.","title":"1.4 - Backgrounds"},{"location":"guide/basics/npc/","text":"1.5 - NPC Placement NPCs (Also known as Entities) are in-game objects used for cutscenes and as enemies. NPCs can be stored in maps. Individual map NPC placement is stored in .pxe files that can be found in the data/Stage/ folder. NPCs use Tile Unit coordinates when stored in PXE files, but in-game they use Pixel Unit coordinates. 1.5.1 - PXE Entry Parameters Individual entries in PXE files can have unique parameters such as Event ID and Flag ID. These parameters are used with TextScript . Individual entries can also have unique NPC Bits set. 1.5.2 - NPC Sprites NPCs' sprites will be taken from specific parts of either the NPC Spritesheet 1 or 2 specified per Stage Table entry or from global spritesheets. From where NPC sprites are taken is usually specified in an NPC type's NPC Table entry.","title":"1.5 - NPC Placement"},{"location":"guide/basics/npc/#15-npc-placement","text":"NPCs (Also known as Entities) are in-game objects used for cutscenes and as enemies. NPCs can be stored in maps. Individual map NPC placement is stored in .pxe files that can be found in the data/Stage/ folder. NPCs use Tile Unit coordinates when stored in PXE files, but in-game they use Pixel Unit coordinates.","title":"1.5 - NPC Placement"},{"location":"guide/basics/npc/#151-pxe-entry-parameters","text":"Individual entries in PXE files can have unique parameters such as Event ID and Flag ID. These parameters are used with TextScript . Individual entries can also have unique NPC Bits set.","title":"1.5.1 - PXE Entry Parameters"},{"location":"guide/basics/npc/#152-npc-sprites","text":"NPCs' sprites will be taken from specific parts of either the NPC Spritesheet 1 or 2 specified per Stage Table entry or from global spritesheets. From where NPC sprites are taken is usually specified in an NPC type's NPC Table entry.","title":"1.5.2 - NPC Sprites"},{"location":"guide/basics/npctbl/","text":"1.6 - NPC Table The NPC Table is a table of default properties for each NPC type. It'ss stored in the data/npc.tbl file. Editing the NPC Table can be used to change basic properties such as HP, damage, exp price, hitbox, spritesheet or default bits . Some NPCs dynamically change such values, which would mean that changing these NPCs' NPC Table entry values may have little effect. For such NPCs Scripting should be used instead. Warning When editing NPC hitboxes make sure that the front and back (left and right) values of the hitbox are the same, otherwise you might get weird hitbox behavior.","title":"1.6 - NPC Table"},{"location":"guide/basics/npctbl/#16-npc-table","text":"The NPC Table is a table of default properties for each NPC type. It'ss stored in the data/npc.tbl file. Editing the NPC Table can be used to change basic properties such as HP, damage, exp price, hitbox, spritesheet or default bits . Some NPCs dynamically change such values, which would mean that changing these NPCs' NPC Table entry values may have little effect. For such NPCs Scripting should be used instead. Warning When editing NPC hitboxes make sure that the front and back (left and right) values of the hitbox are the same, otherwise you might get weird hitbox behavior.","title":"1.6 - NPC Table"},{"location":"guide/basics/stage/","text":"1.2 - Stage Table At this point you are probably wondering \"what is a stage table anyway\". The Stage Table is what Cave Story uses to transfer between different rooms. Usually when the player enters a door that transfers them to another room, the game is saying \"Transfer to Stage Number X\" and data from Stage Table entry No. X is loaded. The Stage Table in ModCS is stored in the stage.tbl file. In the Freeware EXE it's hardcoded into the EXE. You may create, edit and delete Stage Table entries in Cave Story editors. Note Contrary to popular belief making and deleting Stage Table entries in editors such as Booster's Lab does not create or delete map files. Stage Table entries are just what they are - Some info which points to map files in their \"Filename\" section. The reason people believe deleting Stage Table entries in editors deletes the map files too is because when you click on a Stage Table entry which points to map files that do not eixst, Booster's Lab creates empty map files for you. While you may delete and move Stage Table entries it's important to note that things such as Save Files, the Opening sequence and New Game may break if certain stages end up in the wrong order. Scripting allows you to change the Opening sequence and New Game stages, but more on that in the Scripting section.","title":"1.2 - Stage Table"},{"location":"guide/basics/stage/#12-stage-table","text":"At this point you are probably wondering \"what is a stage table anyway\". The Stage Table is what Cave Story uses to transfer between different rooms. Usually when the player enters a door that transfers them to another room, the game is saying \"Transfer to Stage Number X\" and data from Stage Table entry No. X is loaded. The Stage Table in ModCS is stored in the stage.tbl file. In the Freeware EXE it's hardcoded into the EXE. You may create, edit and delete Stage Table entries in Cave Story editors. Note Contrary to popular belief making and deleting Stage Table entries in editors such as Booster's Lab does not create or delete map files. Stage Table entries are just what they are - Some info which points to map files in their \"Filename\" section. The reason people believe deleting Stage Table entries in editors deletes the map files too is because when you click on a Stage Table entry which points to map files that do not eixst, Booster's Lab creates empty map files for you. While you may delete and move Stage Table entries it's important to note that things such as Save Files, the Opening sequence and New Game may break if certain stages end up in the wrong order. Scripting allows you to change the Opening sequence and New Game stages, but more on that in the Scripting section.","title":"1.2 - Stage Table"},{"location":"guide/basics/tiles/","text":"1.3 - Tile Editing Tile Editing is the act of placing tiles. It's quite fascinating. Tile placement is stored in .pxm files that can be found in the data/Stage/ folder. PXM stands for PixMap. 1.3.1 - Tilesets and Tile attributes Tilesets are contained in two kinds of files: .bmp files stored in the data/Stage/ folder with the prefix Prt (Example: PrtCave.bmp ) which store the tileset's bitmap and .pxa files stored in the data/Stage/ folder (Example Cave.pxa ) which store the tileset's tile attributes. Tile Attributes is a collection of data which represent how certain tiles act in-game (If they are slope tiles, water tiles, etc.). In Booster's Lab you may edit the Attribute of a tile by right clicking it in the Tileset viewer. Left clicking on any tile attribute will change it. 1.3.1.1 - Custom Tilesets To use a custom tileset simply create a PrtName.bmp in your data/Stage/ folder (Where Name is the name of your Tileset). Choosing it in editors' Stage Table entry editor will automatically create an empty .pxa file for you. The game will fail to load Tileset bitmaps over 256x256.","title":"1.3 - Tile Editing"},{"location":"guide/basics/tiles/#13-tile-editing","text":"Tile Editing is the act of placing tiles. It's quite fascinating. Tile placement is stored in .pxm files that can be found in the data/Stage/ folder. PXM stands for PixMap.","title":"1.3 - Tile Editing"},{"location":"guide/basics/tiles/#131-tilesets-and-tile-attributes","text":"Tilesets are contained in two kinds of files: .bmp files stored in the data/Stage/ folder with the prefix Prt (Example: PrtCave.bmp ) which store the tileset's bitmap and .pxa files stored in the data/Stage/ folder (Example Cave.pxa ) which store the tileset's tile attributes. Tile Attributes is a collection of data which represent how certain tiles act in-game (If they are slope tiles, water tiles, etc.). In Booster's Lab you may edit the Attribute of a tile by right clicking it in the Tileset viewer. Left clicking on any tile attribute will change it.","title":"1.3.1 - Tilesets and Tile attributes"},{"location":"guide/basics/tiles/#1311-custom-tilesets","text":"To use a custom tileset simply create a PrtName.bmp in your data/Stage/ folder (Where Name is the name of your Tileset). Choosing it in editors' Stage Table entry editor will automatically create an empty .pxa file for you. The game will fail to load Tileset bitmaps over 256x256.","title":"1.3.1.1 - Custom Tilesets"},{"location":"guide/basics/ui/","text":"1.1 - Interface After you've opened your mod you may double-click on any of the Stages in the side bar to start editing. Stage Table viewer - The sidebar shows the list of Stages in the Stage Table. Double-clicking on any stage here will open it in the Editor Section. Cursor tile coordinates - Shows the Tile Unit coordinates of your cursor. Mode switcher - Lets you change edit modes. Stage tabs - This is where tabs of different stages will be stored. You may close a tab with Ctrl+W. Editor Section - This is where stage editing is mostly done. 1.1.1 - Frequently Asked Questions Q: What's the difference between File->Save and File->Save All in Booster's Lab? A: File->Save only saves edits of the currently opened Stage tab, while File->Save All saves every map and Stage Table edits.","title":"1.1 - Interface"},{"location":"guide/basics/ui/#11-interface","text":"After you've opened your mod you may double-click on any of the Stages in the side bar to start editing. Stage Table viewer - The sidebar shows the list of Stages in the Stage Table. Double-clicking on any stage here will open it in the Editor Section. Cursor tile coordinates - Shows the Tile Unit coordinates of your cursor. Mode switcher - Lets you change edit modes. Stage tabs - This is where tabs of different stages will be stored. You may close a tab with Ctrl+W. Editor Section - This is where stage editing is mostly done.","title":"1.1 - Interface"},{"location":"guide/basics/ui/#111-frequently-asked-questions","text":"Q: What's the difference between File->Save and File->Save All in Booster's Lab? A: File->Save only saves edits of the currently opened Stage tab, while File->Save All saves every map and Stage Table edits.","title":"1.1.1 - Frequently Asked Questions"},{"location":"guide/intro/editors/","text":"0.2 - Installing an Editor To mod Cave Story you will need a visual editor for property tables, maps, etc. Cave Story Map Editors usually contain all the tools you would need at once. There are 3 editors the community still actively uses and 2 editors which can be used with ModCS . 0.2.1 - Booster's Lab (Recommended) Pros Cons Designed for low-end PCs. Still maintained but not very actively updated. Works on any OS which Java supports. May be buggy and glitchy at times. The most supported by the community editor. Confusing UI design. Note Booster's Lab is the editor this guide will mainly focus on. However, you should be able to figure out where different features on different editors are with ease. This guide personally reccomends using Booster's Lab. Download and extract Booster's Lab from here: Download Booster's Lab (v0.5.1.1) To launch Booster's Lab, run launch_classic.bat . Warning Absolutely never use launch_layers.bat on your mod. \"Layers Mode\" is experimental and the only thing it will do on a normal mod is 'corrupt' all of its map files. 0.2.2 The King's Table Pros Cons Actively updated. Work in progress and experimental editor. Supports a variety of different mod setups. Every map is a separate Window. Doesn't require Java installed. Only officially supported OS is Windows. Download and extract The King's Table from here: Download The King's Table To launch The King's Table, run CaveStoryEditor.exe . 0.2.3 Cave Editor There really is not much there to say about Cave Editor. It is heavily outdated and does not support ModCS. Download Cave Editor (v0.99d)","title":"0.2 - Installing an Editor"},{"location":"guide/intro/editors/#02-installing-an-editor","text":"To mod Cave Story you will need a visual editor for property tables, maps, etc. Cave Story Map Editors usually contain all the tools you would need at once. There are 3 editors the community still actively uses and 2 editors which can be used with ModCS .","title":"0.2 - Installing an Editor"},{"location":"guide/intro/editors/#021-boosters-lab-recommended","text":"Pros Cons Designed for low-end PCs. Still maintained but not very actively updated. Works on any OS which Java supports. May be buggy and glitchy at times. The most supported by the community editor. Confusing UI design. Note Booster's Lab is the editor this guide will mainly focus on. However, you should be able to figure out where different features on different editors are with ease. This guide personally reccomends using Booster's Lab. Download and extract Booster's Lab from here: Download Booster's Lab (v0.5.1.1) To launch Booster's Lab, run launch_classic.bat . Warning Absolutely never use launch_layers.bat on your mod. \"Layers Mode\" is experimental and the only thing it will do on a normal mod is 'corrupt' all of its map files.","title":"0.2.1 - Booster's Lab (Recommended)"},{"location":"guide/intro/editors/#022-the-kings-table","text":"Pros Cons Actively updated. Work in progress and experimental editor. Supports a variety of different mod setups. Every map is a separate Window. Doesn't require Java installed. Only officially supported OS is Windows. Download and extract The King's Table from here: Download The King's Table To launch The King's Table, run CaveStoryEditor.exe .","title":"0.2.2 The King's Table"},{"location":"guide/intro/editors/#023-cave-editor","text":"There really is not much there to say about Cave Editor. It is heavily outdated and does not support ModCS. Download Cave Editor (v0.99d)","title":"0.2.3 Cave Editor"},{"location":"guide/intro/install/","text":"0.1 - Installation and getting ready Now, obviously, you would have to download ModCS. Download Latest ModCS The downloaded ZIP will need to be extracted before usage, you can do that with a program like 7-Zip . This download contains: The ModCS EXE A DoConfig EXE A vanilla data folder containing all vanilla data folder assets, with PBMs renamed to BMPs. Extra files necessary for ModCS to function ( data/stage.tbl , data/bullet.tbl , data/caret.tbl , data/music.tbl , data/Scripts/main.lua ) 0.1.1 - Migrating a mod to ModCS If you simply want to switch engines from another engine (Original Freeware EXE, CSE2, etc.) to ModCS then you are probably not willing to start with the vanilla data folder. This section will cover how to migrate from Freeware and from CSE2 Enhanced. Important Please note that this section only focuses on migrating data folders , not modifications to the EXE. Any source code edits or Assembly hacks you wish to migrate will have to be recreated with the Lua scripting API manually. Depending on the edits you wish to migrate this might be an easy process. 0.1.1.1 - Migrating from Freeware The following guide will show you how to migrate a Freeware data folder to ModCS. Make sure all bitmaps in your data folder have a .bmp extension. Create a Scripts folder in data and create an empty main.lua file there. (Make sure you edit the file extension). From a vanilla ModCS install copy the data/bullet.tbl file (Or from a PC Cave Story+ install copy the data/base/bullet.tbl file) to your mod's data folder. From a vanilla ModCS install copy the data/caret.tbl and data/music.tbl files to your mod's data folder. Move all ORG files from Resources to a data/Org folder using Resource Hacker (Make sure they have a .org file extension). Move all Credit bitmaps from Resources to a data/Credits folder using Resource Hacker (Make sure they have a .bmp file extension). Move the PIXEL bitmap from Resources to the data folder using Resource Hacker (Make sure it has a .bmp file extension). Using The King's Table convert your Stage Table to a stage.tbl and place it in your data folder. Replace your mod EXE with the ModCS EXE. 0.1.1.2 - Migrating from CSE2 Enhanced The following guide will show you how to migrate a CSE2 Enhanced data folder to ModCS. Note This guide only focuses on the most common CSE2 Enhanced data folder format. (.png files + mrmap.bin). For anything else, you're on your own. Replace all transparent pixels in your .png files with pure black pixels (RGB 0, 0, 0; HEX #000000) in an image editing tool. Save them all as 24-bit .bmp s in your image editing tool and delete all of the original .png s. This is done because ModCS does not support the PNG format. Move the data/PixTone folder to somewhere else, as its not used by ModCS. Move all Credit images from data/Resource/BITMAP to data/Credits . Move Pixel.bmp from data/Resource/BITMAP to data . Move all ORG files from data/Resource/ORG to data/Org . Create a Scripts folder in data and create an empty main.lua file there. (Make sure you edit the file extension). From a vanilla ModCS install copy the data/bullet.tbl file (Or from a PC Cave Story+ install copy the data/base/bullet.tbl file) to your mod's data folder. From a vanilla ModCS install copy the data/caret.tbl and data/music.tbl files to your mod's data folder. Using The King's Table convert your data/mrmap.bin file to a stage.tbl . Replace your mod EXE with the ModCS EXE.","title":"0.1 - Installation and getting ready"},{"location":"guide/intro/install/#01-installation-and-getting-ready","text":"Now, obviously, you would have to download ModCS. Download Latest ModCS The downloaded ZIP will need to be extracted before usage, you can do that with a program like 7-Zip . This download contains: The ModCS EXE A DoConfig EXE A vanilla data folder containing all vanilla data folder assets, with PBMs renamed to BMPs. Extra files necessary for ModCS to function ( data/stage.tbl , data/bullet.tbl , data/caret.tbl , data/music.tbl , data/Scripts/main.lua )","title":"0.1 - Installation and getting ready"},{"location":"guide/intro/install/#011-migrating-a-mod-to-modcs","text":"If you simply want to switch engines from another engine (Original Freeware EXE, CSE2, etc.) to ModCS then you are probably not willing to start with the vanilla data folder. This section will cover how to migrate from Freeware and from CSE2 Enhanced. Important Please note that this section only focuses on migrating data folders , not modifications to the EXE. Any source code edits or Assembly hacks you wish to migrate will have to be recreated with the Lua scripting API manually. Depending on the edits you wish to migrate this might be an easy process.","title":"0.1.1 - Migrating a mod to ModCS"},{"location":"guide/intro/install/#0111-migrating-from-freeware","text":"The following guide will show you how to migrate a Freeware data folder to ModCS. Make sure all bitmaps in your data folder have a .bmp extension. Create a Scripts folder in data and create an empty main.lua file there. (Make sure you edit the file extension). From a vanilla ModCS install copy the data/bullet.tbl file (Or from a PC Cave Story+ install copy the data/base/bullet.tbl file) to your mod's data folder. From a vanilla ModCS install copy the data/caret.tbl and data/music.tbl files to your mod's data folder. Move all ORG files from Resources to a data/Org folder using Resource Hacker (Make sure they have a .org file extension). Move all Credit bitmaps from Resources to a data/Credits folder using Resource Hacker (Make sure they have a .bmp file extension). Move the PIXEL bitmap from Resources to the data folder using Resource Hacker (Make sure it has a .bmp file extension). Using The King's Table convert your Stage Table to a stage.tbl and place it in your data folder. Replace your mod EXE with the ModCS EXE.","title":"0.1.1.1 - Migrating from Freeware"},{"location":"guide/intro/install/#0112-migrating-from-cse2-enhanced","text":"The following guide will show you how to migrate a CSE2 Enhanced data folder to ModCS. Note This guide only focuses on the most common CSE2 Enhanced data folder format. (.png files + mrmap.bin). For anything else, you're on your own. Replace all transparent pixels in your .png files with pure black pixels (RGB 0, 0, 0; HEX #000000) in an image editing tool. Save them all as 24-bit .bmp s in your image editing tool and delete all of the original .png s. This is done because ModCS does not support the PNG format. Move the data/PixTone folder to somewhere else, as its not used by ModCS. Move all Credit images from data/Resource/BITMAP to data/Credits . Move Pixel.bmp from data/Resource/BITMAP to data . Move all ORG files from data/Resource/ORG to data/Org . Create a Scripts folder in data and create an empty main.lua file there. (Make sure you edit the file extension). From a vanilla ModCS install copy the data/bullet.tbl file (Or from a PC Cave Story+ install copy the data/base/bullet.tbl file) to your mod's data folder. From a vanilla ModCS install copy the data/caret.tbl and data/music.tbl files to your mod's data folder. Using The King's Table convert your data/mrmap.bin file to a stage.tbl . Replace your mod EXE with the ModCS EXE.","title":"0.1.1.2 - Migrating from CSE2 Enhanced"},{"location":"guide/lua/basic/","text":"3.1 - Basics To get started with Lua scripting you may want to create a blank debug file without a file extension in the same folder as the ModCS EXE . This will enable various debug features and most importantly a debug console, which can be used for printing values to using print() . The main Lua file that is ran when ModCS runs is stored in the data/Scripts/ folder as main.lua . Additional files stored in data/Scripts/ may be included using require . You may test that main.lua is executing correctly simply by opening it with a text editor and putting a print() with a string or number. print(\"Hello World!\") should print a Hello World! to the debug console once the game is launched. 3.1.1 - Game Modes The main game loop of Cave Story is separated into 3 modes: Value Game mode 1 Opening sequence. 2 Title screen. 3 Action. You can 'get' the number of the current game mode using ModCS.Game.GetMode() . Putting print(ModCS.Game.GetMode()) in the main.lua file will print the game mode to the debug console once the game launches. However, this isn't very practical as this print() will only run when the game launches and the game starts with the opening sequence, meaning that the result of the print() will always be 1.0 being printed to the debug console. To have a piece of code run every time the game switches game modes you can put it in a globally defined ModCS.Game.Init() function. Example 1 2 3 4 5 6 7 8 9 -- Define ModCS.Game.Init() function ModCS . Game . Init () --[[ Every time a new game mode starts print \"New game mode started\" and the ID of the game mode --]] print ( \"New game mode started: \" .. ModCS . Game . GetMode ()) end This should print out New game mode started: 1.0 , New game mode started: 2.0 or New game mode started: 3.0 depending on the initialized game mode. 3.1.2 - Key checking and ModCS.Game.Act() For things you might want to actively check, something that runs once will not be suited. Instead, you might want to put code meant for an active loop into a globally defined ModCS.Game.Act() function. Example 1 2 3 4 5 6 7 8 -- Define ModCS.Game.Act() function ModCS . Game . Act () --[[ Infinitely print \"This is an active loop\" into the debug console. --]] print ( \"This is an active loop\" ) end Something you might want to actively check is key presses . You can use functions contained in the ModCS.Key namespace to check for pressed keys. As an example of use of key presses we are going to make the game add 1 to a variable and print that variable to the debug console every time the player presses the Minimap button (W). Example 1 2 3 4 5 6 7 8 local number = 0 -- Define local variable number function ModCS . Game . Act () if ( ModCS . Key . Map ()) then -- If map key is pressed... number = number + 1 -- Add 1 to number print ( number ) -- Print the result end end The game will now count the number of times the Minimap button (W) has been pressed and print it to the debug console for us.","title":"3.1 - Basics"},{"location":"guide/lua/basic/#31-basics","text":"To get started with Lua scripting you may want to create a blank debug file without a file extension in the same folder as the ModCS EXE . This will enable various debug features and most importantly a debug console, which can be used for printing values to using print() . The main Lua file that is ran when ModCS runs is stored in the data/Scripts/ folder as main.lua . Additional files stored in data/Scripts/ may be included using require . You may test that main.lua is executing correctly simply by opening it with a text editor and putting a print() with a string or number. print(\"Hello World!\") should print a Hello World! to the debug console once the game is launched.","title":"3.1 - Basics"},{"location":"guide/lua/basic/#311-game-modes","text":"The main game loop of Cave Story is separated into 3 modes: Value Game mode 1 Opening sequence. 2 Title screen. 3 Action. You can 'get' the number of the current game mode using ModCS.Game.GetMode() . Putting print(ModCS.Game.GetMode()) in the main.lua file will print the game mode to the debug console once the game launches. However, this isn't very practical as this print() will only run when the game launches and the game starts with the opening sequence, meaning that the result of the print() will always be 1.0 being printed to the debug console. To have a piece of code run every time the game switches game modes you can put it in a globally defined ModCS.Game.Init() function. Example 1 2 3 4 5 6 7 8 9 -- Define ModCS.Game.Init() function ModCS . Game . Init () --[[ Every time a new game mode starts print \"New game mode started\" and the ID of the game mode --]] print ( \"New game mode started: \" .. ModCS . Game . GetMode ()) end This should print out New game mode started: 1.0 , New game mode started: 2.0 or New game mode started: 3.0 depending on the initialized game mode.","title":"3.1.1 - Game Modes"},{"location":"guide/lua/basic/#312-key-checking-and-modcsgameact","text":"For things you might want to actively check, something that runs once will not be suited. Instead, you might want to put code meant for an active loop into a globally defined ModCS.Game.Act() function. Example 1 2 3 4 5 6 7 8 -- Define ModCS.Game.Act() function ModCS . Game . Act () --[[ Infinitely print \"This is an active loop\" into the debug console. --]] print ( \"This is an active loop\" ) end Something you might want to actively check is key presses . You can use functions contained in the ModCS.Key namespace to check for pressed keys. As an example of use of key presses we are going to make the game add 1 to a variable and print that variable to the debug console every time the player presses the Minimap button (W). Example 1 2 3 4 5 6 7 8 local number = 0 -- Define local variable number function ModCS . Game . Act () if ( ModCS . Key . Map ()) then -- If map key is pressed... number = number + 1 -- Add 1 to number print ( number ) -- Print the result end end The game will now count the number of times the Minimap button (W) has been pressed and print it to the debug console for us.","title":"3.1.2 - Key checking and ModCS.Game.Act()"},{"location":"guide/lua/drawing/","text":"3.2 - Drawing Drawing is the act of putting a sprite on the screen. When the game draws directly to the screen it does it in a loop. Most of the time drawing directly to the screen in a single will result in the next frame drawing over it. ModCS will run on loop things put in a globally defined ModCS.Game.Draw() function. The difference between ModCS.Game.Act() and ModCS.Game.Draw() is when they're called in-game. ModCS.Game.Act() is ran before anything is drawn on the screen, therefore anything drawn in it will not appear because it will be 'overdrawn' by the things that draw after it. On the other hand ModCS.Game.Draw() runs after everything has been drawn on the screen, and anything drawn on it will appear over everything drawn so far. Note Similarly to ModCS.Game.Act() , ModCS.Game.Draw() only runs during the main game loop. As an example of drawing we will continue off the example number addition code from the previous page. ModCS.PutNumber() will draw a number sprite of a given number to specific screen coordinates. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 local number = 0 -- Define local variable number function ModCS . Game . Act () if ( ModCS . Key . Map ()) then -- If map key is pressed... number = number + 1 -- Add 1 to number print ( number ) -- Print the result end end function ModCS . Game . Draw () ModCS . PutNumber ( number , 0 , 0 ) -- Draw the number to the screen end The two numbers after number represent X and Y coordinates. For example if you wanted to draw the number in the center of the screen you would do ModCS.PutNumber(number, 160, 120) (Please note that ModCS.PutNumber() offsets the coordinates a little so it can contain up to 4 digit numbers. If you would like to experiment with exact coordinates you may use ModCS.PutText ). 3.2.1 - Surfaces Surfaces are image data types which contain pixels of an image. They are used in-game to have sprites drawn from. For example the player sprites are contained in Surface with ID 16 . Some Surfaces are simply loaded from a .bmp image when the game launches (Surface 16 is taken from data/MyChar.bmp ). Others are more complicated, such as the Tileset Surface (Surface 2 ), which is used by the game to load the tileset .bmp file specified in a Stage Table entry to, and from where any tiles are drawn from. After Surfaces are created their sizes cannot be changed. Surfaces loaded from .bmp files take their sizes from the .bmp files they were created with. Other surfaces have to be created with specified sizes. This is why things such as per-Stage NPC Sheets (Surfaces 21 and 22 ) are limited to 320x240. 3.2.2 - Rects Rects are a pair of X and Y coordinates which represent a part of a Surface. They are usually used for displaying different sprites from a Surface. You may create a Rect variable with ModCS.Rect.Create() . Example 1 local ExampleRect = ModCS . Rect . Create () Rect variables contain the following values: Value Usage left X coordinate of the upper-left corner of the Rect. top Y coordinate of the upper-left corner of the Rect. right X coordinate of the down-right corner of the Rect. bottom Y coordinate of the down-right corner of the Rect. As an example we can try to get the Rect of the number 4 sprite from data/TextBox.bmp . The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore we may set our Example Rect variable to the Rect of the number 4 like this: Example 1 2 3 4 5 6 local ExampleRect = ModCS . Rect . Create () ExampleRect . left = 32 ExampleRect . top = 56 ExampleRect . right = 40 ExampleRect . bottom = 64 A cleaner way would be using ModCS.Rect.Set() : Example 1 2 3 local ExampleRect = ModCS . Rect . Create () ExampleRect : Set ( 32 , 56 , 40 , 64 ) An even cleaner way would be creating the Rect variable by giving the left , top , right and bottom values straight to ModCS.Rect.Create() : Example 1 local ExampleRect = ModCS . Rect . Create ( 32 , 56 , 40 , 64 ) Rects can be drawn to the screen using ModCS.Rect.Put() . For example, if we wanted to draw our example rect from earlier to the center of the screen we would do this: Example 1 2 3 4 5 local ExampleRect = ModCS . Rect . Create ( 32 , 56 , 40 , 64 ) function ModCS . Game . Draw () ExampleRect : Put ( 160 , 120 , 26 ) end 26 is the ID of the Surface we will be drawing from (Surface 26 is the Surface to where data/TextBox.bmp is loaded to).","title":"3.2 - Drawing"},{"location":"guide/lua/drawing/#32-drawing","text":"Drawing is the act of putting a sprite on the screen. When the game draws directly to the screen it does it in a loop. Most of the time drawing directly to the screen in a single will result in the next frame drawing over it. ModCS will run on loop things put in a globally defined ModCS.Game.Draw() function. The difference between ModCS.Game.Act() and ModCS.Game.Draw() is when they're called in-game. ModCS.Game.Act() is ran before anything is drawn on the screen, therefore anything drawn in it will not appear because it will be 'overdrawn' by the things that draw after it. On the other hand ModCS.Game.Draw() runs after everything has been drawn on the screen, and anything drawn on it will appear over everything drawn so far. Note Similarly to ModCS.Game.Act() , ModCS.Game.Draw() only runs during the main game loop. As an example of drawing we will continue off the example number addition code from the previous page. ModCS.PutNumber() will draw a number sprite of a given number to specific screen coordinates. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 local number = 0 -- Define local variable number function ModCS . Game . Act () if ( ModCS . Key . Map ()) then -- If map key is pressed... number = number + 1 -- Add 1 to number print ( number ) -- Print the result end end function ModCS . Game . Draw () ModCS . PutNumber ( number , 0 , 0 ) -- Draw the number to the screen end The two numbers after number represent X and Y coordinates. For example if you wanted to draw the number in the center of the screen you would do ModCS.PutNumber(number, 160, 120) (Please note that ModCS.PutNumber() offsets the coordinates a little so it can contain up to 4 digit numbers. If you would like to experiment with exact coordinates you may use ModCS.PutText ).","title":"3.2 - Drawing"},{"location":"guide/lua/drawing/#321-surfaces","text":"Surfaces are image data types which contain pixels of an image. They are used in-game to have sprites drawn from. For example the player sprites are contained in Surface with ID 16 . Some Surfaces are simply loaded from a .bmp image when the game launches (Surface 16 is taken from data/MyChar.bmp ). Others are more complicated, such as the Tileset Surface (Surface 2 ), which is used by the game to load the tileset .bmp file specified in a Stage Table entry to, and from where any tiles are drawn from. After Surfaces are created their sizes cannot be changed. Surfaces loaded from .bmp files take their sizes from the .bmp files they were created with. Other surfaces have to be created with specified sizes. This is why things such as per-Stage NPC Sheets (Surfaces 21 and 22 ) are limited to 320x240.","title":"3.2.1 - Surfaces"},{"location":"guide/lua/drawing/#322-rects","text":"Rects are a pair of X and Y coordinates which represent a part of a Surface. They are usually used for displaying different sprites from a Surface. You may create a Rect variable with ModCS.Rect.Create() . Example 1 local ExampleRect = ModCS . Rect . Create () Rect variables contain the following values: Value Usage left X coordinate of the upper-left corner of the Rect. top Y coordinate of the upper-left corner of the Rect. right X coordinate of the down-right corner of the Rect. bottom Y coordinate of the down-right corner of the Rect. As an example we can try to get the Rect of the number 4 sprite from data/TextBox.bmp . The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore we may set our Example Rect variable to the Rect of the number 4 like this: Example 1 2 3 4 5 6 local ExampleRect = ModCS . Rect . Create () ExampleRect . left = 32 ExampleRect . top = 56 ExampleRect . right = 40 ExampleRect . bottom = 64 A cleaner way would be using ModCS.Rect.Set() : Example 1 2 3 local ExampleRect = ModCS . Rect . Create () ExampleRect : Set ( 32 , 56 , 40 , 64 ) An even cleaner way would be creating the Rect variable by giving the left , top , right and bottom values straight to ModCS.Rect.Create() : Example 1 local ExampleRect = ModCS . Rect . Create ( 32 , 56 , 40 , 64 ) Rects can be drawn to the screen using ModCS.Rect.Put() . For example, if we wanted to draw our example rect from earlier to the center of the screen we would do this: Example 1 2 3 4 5 local ExampleRect = ModCS . Rect . Create ( 32 , 56 , 40 , 64 ) function ModCS . Game . Draw () ExampleRect : Put ( 160 , 120 , 26 ) end 26 is the ID of the Surface we will be drawing from (Surface 26 is the Surface to where data/TextBox.bmp is loaded to).","title":"3.2.2 - Rects"},{"location":"guide/lua/npc/","text":"3.3 - NPCs One of ModCS's Lua API main features is its NPC API . In this section of the guide we will be going over basic NPC editing. To begin editing an NPC Type you simply have to define a ModCS.Npc.ActX() function, where X is the NPC Type ID you would like to edit. This function will run every frame an NPC of X type exists. The first argument given to this function will be the NPC for which this function is running. Using ModCS.Npc.ActCode() you may run vanilla NPC code for the NPC given in the function. Example 1 2 3 4 5 6 7 8 9 10 11 12 --[[ For every NPC with type 64 (First Cave Critter) this function will run, and the NPC will be passed to the function as `npc` --]] function ModCS . Npc . Act64 ( npc ) --[[ Run the vanilla game code for NPC ID 64 (First Cave Critter) for `npc` --]] npc : ActCode ( 64 ) end Doing this will now allow us to inject custom code in the code of NPC type 64, which is the First Cave Critter. The First Cave Critter, like many vanilla NPCs, uses Act States to differentiate between how the NPC should act in certain scenarios. Example 1 2 3 4 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) print ( npc . act_no ) end Using this code while there is a single NPC of type 64 on screen will allow you to find out what different Act States of the NPC do. With this method you can find out the Act States of the First Cave Critter NPC: Act State 1 - Idle Act State 2 - Jumped Act State 3 - Falling This information can help us do certain modifications to the NPC in our code. For example, we can make First Cave Critters spawn smoke once they land on the floor after a fall: Example 1 2 3 4 5 6 7 function ModCS . Npc . Act64 ( npc ) if ( npc . act_no == 3 and npc : TouchFloor ()) then ModCS . Npc . Spawn ( 4 , npc . x , npc . y ) end npc : ActCode ( 64 ) end 3.3.1 - Editing NPC Rects Note This part of the guide is for advanced Rect changing. While it's still recommended to read it, if you simply wish to offset the sprites of an NPC from a spritesheet use ModCS.Npc.OffsetRect() . Similarly to Act States, most NPCs also have Animation States . These define what sprite the NPC should be currently using. You can find out Animation States using a similar method as the one for finding out Act States: Example 1 2 3 4 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) print ( npc . ani_no ) end Animation State 1- Closed eyes Animation State 2 - Opened eyes Animation State 3 - Jumping Using this information and ModCS.Npc.SetRect() we can change the Rects of the NPC. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) local rcLeft = { ModCS . Rect . Create ( 0 , 0 , 16 , 16 ), ModCS . Rect . Create ( 16 , 0 , 32 , 16 ), ModCS . Rect . Create ( 32 , 0 , 48 , 16 ) } local rcRight = { ModCS . Rect . Create ( 0 , 16 , 16 , 32 ), ModCS . Rect . Create ( 16 , 16 , 32 , 32 ), ModCS . Rect . Create ( 32 , 16 , 48 , 32 ) } --[[ The game doesn't do flipped sprites automatically, but we can do them ourselves using npc.direct --]] if ( npc . direct == 0 ) then --[[ Lua table indexes start at 1 and animation states start at 0, so we add +1 to the table access index --]] npc : SetRect ( rcLeft [ npc . ani_no + 1 ]) elseif ( npc . direct == 2 ) then npc : SetRect ( rcRight [ npc . ani_no + 1 ]) end end For a better table syntax, you might want to do regular number tables rather than a table with Rect variables: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) local rcLeft = { { 0 , 0 , 16 , 16 }, { 16 , 0 , 32 , 16 }, { 32 , 0 , 48 , 16 } } local rcRight = { { 0 , 16 , 16 , 32 }, { 16 , 16 , 32 , 32 }, { 32 , 16 , 48 , 32 } } if ( npc . direct == 0 ) then npc : SetRect ( rcLeft [ npc . ani_no + 1 ][ 1 ], rcLeft [ npc . ani_no + 1 ][ 2 ], rcLeft [ npc . ani_no + 1 ][ 3 ], rcLeft [ npc . ani_no + 1 ][ 4 ]) elseif ( npc . direct == 2 ) then npc : SetRect ( rcRight [ npc . ani_no + 1 ][ 1 ], rcRight [ npc . ani_no + 1 ][ 2 ], rcRight [ npc . ani_no + 1 ][ 3 ], rcRight [ npc . ani_no + 1 ][ 4 ]) end end 3.3.2 - Making NPCs from scratch NPC Act functions do not have to contain ModCS.Npc.ActCode() , which allows you to create NPC Types entirely from scratch. This can be done in several ways, so this guide won't go over a definitive way to make NPCs. Instead I recommend checking out examples, reading the documentation or reading NPC code of other people.","title":"3.3 - NPCs"},{"location":"guide/lua/npc/#33-npcs","text":"One of ModCS's Lua API main features is its NPC API . In this section of the guide we will be going over basic NPC editing. To begin editing an NPC Type you simply have to define a ModCS.Npc.ActX() function, where X is the NPC Type ID you would like to edit. This function will run every frame an NPC of X type exists. The first argument given to this function will be the NPC for which this function is running. Using ModCS.Npc.ActCode() you may run vanilla NPC code for the NPC given in the function. Example 1 2 3 4 5 6 7 8 9 10 11 12 --[[ For every NPC with type 64 (First Cave Critter) this function will run, and the NPC will be passed to the function as `npc` --]] function ModCS . Npc . Act64 ( npc ) --[[ Run the vanilla game code for NPC ID 64 (First Cave Critter) for `npc` --]] npc : ActCode ( 64 ) end Doing this will now allow us to inject custom code in the code of NPC type 64, which is the First Cave Critter. The First Cave Critter, like many vanilla NPCs, uses Act States to differentiate between how the NPC should act in certain scenarios. Example 1 2 3 4 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) print ( npc . act_no ) end Using this code while there is a single NPC of type 64 on screen will allow you to find out what different Act States of the NPC do. With this method you can find out the Act States of the First Cave Critter NPC: Act State 1 - Idle Act State 2 - Jumped Act State 3 - Falling This information can help us do certain modifications to the NPC in our code. For example, we can make First Cave Critters spawn smoke once they land on the floor after a fall: Example 1 2 3 4 5 6 7 function ModCS . Npc . Act64 ( npc ) if ( npc . act_no == 3 and npc : TouchFloor ()) then ModCS . Npc . Spawn ( 4 , npc . x , npc . y ) end npc : ActCode ( 64 ) end","title":"3.3 - NPCs"},{"location":"guide/lua/npc/#331-editing-npc-rects","text":"Note This part of the guide is for advanced Rect changing. While it's still recommended to read it, if you simply wish to offset the sprites of an NPC from a spritesheet use ModCS.Npc.OffsetRect() . Similarly to Act States, most NPCs also have Animation States . These define what sprite the NPC should be currently using. You can find out Animation States using a similar method as the one for finding out Act States: Example 1 2 3 4 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) print ( npc . ani_no ) end Animation State 1- Closed eyes Animation State 2 - Opened eyes Animation State 3 - Jumping Using this information and ModCS.Npc.SetRect() we can change the Rects of the NPC. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) local rcLeft = { ModCS . Rect . Create ( 0 , 0 , 16 , 16 ), ModCS . Rect . Create ( 16 , 0 , 32 , 16 ), ModCS . Rect . Create ( 32 , 0 , 48 , 16 ) } local rcRight = { ModCS . Rect . Create ( 0 , 16 , 16 , 32 ), ModCS . Rect . Create ( 16 , 16 , 32 , 32 ), ModCS . Rect . Create ( 32 , 16 , 48 , 32 ) } --[[ The game doesn't do flipped sprites automatically, but we can do them ourselves using npc.direct --]] if ( npc . direct == 0 ) then --[[ Lua table indexes start at 1 and animation states start at 0, so we add +1 to the table access index --]] npc : SetRect ( rcLeft [ npc . ani_no + 1 ]) elseif ( npc . direct == 2 ) then npc : SetRect ( rcRight [ npc . ani_no + 1 ]) end end For a better table syntax, you might want to do regular number tables rather than a table with Rect variables: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function ModCS . Npc . Act64 ( npc ) npc : ActCode ( 64 ) local rcLeft = { { 0 , 0 , 16 , 16 }, { 16 , 0 , 32 , 16 }, { 32 , 0 , 48 , 16 } } local rcRight = { { 0 , 16 , 16 , 32 }, { 16 , 16 , 32 , 32 }, { 32 , 16 , 48 , 32 } } if ( npc . direct == 0 ) then npc : SetRect ( rcLeft [ npc . ani_no + 1 ][ 1 ], rcLeft [ npc . ani_no + 1 ][ 2 ], rcLeft [ npc . ani_no + 1 ][ 3 ], rcLeft [ npc . ani_no + 1 ][ 4 ]) elseif ( npc . direct == 2 ) then npc : SetRect ( rcRight [ npc . ani_no + 1 ][ 1 ], rcRight [ npc . ani_no + 1 ][ 2 ], rcRight [ npc . ani_no + 1 ][ 3 ], rcRight [ npc . ani_no + 1 ][ 4 ]) end end","title":"3.3.1 - Editing NPC Rects"},{"location":"guide/lua/npc/#332-making-npcs-from-scratch","text":"NPC Act functions do not have to contain ModCS.Npc.ActCode() , which allows you to create NPC Types entirely from scratch. This can be done in several ways, so this guide won't go over a definitive way to make NPCs. Instead I recommend checking out examples, reading the documentation or reading NPC code of other people.","title":"3.3.2 - Making NPCs from scratch"},{"location":"guide/tsc/box/","text":"2.1 - Making a dialog box appear The most common use of TSC by far is in making dialog boxes. The most basic text script is: #0100 <MSGYour text here!<NOD<CLO<END A few different commands go into making this script work: <MSG -- make the empty dialog box appear <NOD -- wait for the player to press a key before continuing <CLO -- close the dialog box Additionally, note that any non-command text in the script is instead written to the dialog box, provided it is open. Longer dialog will want to use multiple <NOD commands like so: #0100 <MSGWhen they left, the fans turned off permanently.<NOD But recently they started spinning again. I wonder what's making them run...<NOD<CLO Even if there are no explicit breaks in the text itself, it is important to place pauses in an ergonomic way. Since only three lines can be properly on screen at any given time, a well-placed <NOD allows the player to read each set of lines at an appropriate pace. Other commands can be placed in the middle of non-command text, causing them to trigger when that text is displayed: #0100 <MSGAre you ready for a funny noise?<NOD Be<SOU0005eep!<NOD<CLO Here, a sound will be played by the <SOU command right in the middle of the word.","title":"2.1 - Making a dialog box appear"},{"location":"guide/tsc/box/#21-making-a-dialog-box-appear","text":"The most common use of TSC by far is in making dialog boxes. The most basic text script is: #0100 <MSGYour text here!<NOD<CLO<END A few different commands go into making this script work: <MSG -- make the empty dialog box appear <NOD -- wait for the player to press a key before continuing <CLO -- close the dialog box Additionally, note that any non-command text in the script is instead written to the dialog box, provided it is open. Longer dialog will want to use multiple <NOD commands like so: #0100 <MSGWhen they left, the fans turned off permanently.<NOD But recently they started spinning again. I wonder what's making them run...<NOD<CLO Even if there are no explicit breaks in the text itself, it is important to place pauses in an ergonomic way. Since only three lines can be properly on screen at any given time, a well-placed <NOD allows the player to read each set of lines at an appropriate pace. Other commands can be placed in the middle of non-command text, causing them to trigger when that text is displayed: #0100 <MSGAre you ready for a funny noise?<NOD Be<SOU0005eep!<NOD<CLO Here, a sound will be played by the <SOU command right in the middle of the word.","title":"2.1 - Making a dialog box appear"},{"location":"guide/tsc/chest/","text":"2.3 - Making a chest 2.3.1 - Flags In TSC, flags are the primary way of saving information and performing different commands based on that information. A flag has a number associated with it as an ID, and can either be set to ON or OFF. This status is saved to the player's savefile and persists across all stages. Setting a flag to ON is done with the <FL+ command -- e.g. <FL+1000 sets flag number 1000 . Setting a flag to OFF is done with the <FL- command -- e.g. <FL-1000 sets flag number 1000 . Finally, to do different things based on the state of a flag, the <FLJ command is used to jump to different events. For instance: #0100 <FLJ1000:0101 <MSGFlag 1000 is not set.<NOD<CLO<END #0101 <MSGFlag 1000 is set.<NOD<CLO<END If the flag 1000 is set, then rather than continuing to run the commands in event 100 , the game will stop and switch to running the commands in event 101 instead. In total, flags allows you to save permanently when some event occurs, and conditionally split two different possible actions to take into two separate events. 2.3.2 - A chest with a weapon Cave Story does not have a particularly unified item system -- weapons, life capsules, and items all are given to the player through different TSC commands. For a weapon, the <AM+ command is used, which takes the weapon ID and the amount of ammo to give (or 0 for infinite) as arguments. A simple event (attached to a Chest NPC) to give the player a Polar Star might look like: #0100 <PRI<FLJ1000:0101<FL+1000<CNP0200:0021:0000 <MSGOpened the chest.<NOD<GIT0002<AM+0002:0000<CLR Got the =Polar Star=!<WAI0160<NOD<CLO<END #0101 <PRI<MSGEmpty.<NOD<CLO<END Note the use of the flag 1000 here. Once the chest is opened for the first time, the flag will be set, and subsequent interactions will instead display \"Empty.\" A few other new commands: <CNP functions similar to <DNP , but changes the type of the NPC instead. Here we change the associated Chest NPC (#15) to an Opened Chest NPC (#21). <GIT displays an image of an item above the textbox, separate from actually giving the item. <WAI simply waits the specified number of frames. This is used in vanilla Cave Story to wait for all the sounds to finish playing (although this chest does not include them). Additionally, your Chest NPC should have flag 1000 set as its Flag ID. The code for the Chest NPC is set up to switch immediately to being opened if its Flag ID is set, so re-entering the room will leave it open.","title":"2.3 - Making a chest"},{"location":"guide/tsc/chest/#23-making-a-chest","text":"","title":"2.3 - Making a chest"},{"location":"guide/tsc/chest/#231-flags","text":"In TSC, flags are the primary way of saving information and performing different commands based on that information. A flag has a number associated with it as an ID, and can either be set to ON or OFF. This status is saved to the player's savefile and persists across all stages. Setting a flag to ON is done with the <FL+ command -- e.g. <FL+1000 sets flag number 1000 . Setting a flag to OFF is done with the <FL- command -- e.g. <FL-1000 sets flag number 1000 . Finally, to do different things based on the state of a flag, the <FLJ command is used to jump to different events. For instance: #0100 <FLJ1000:0101 <MSGFlag 1000 is not set.<NOD<CLO<END #0101 <MSGFlag 1000 is set.<NOD<CLO<END If the flag 1000 is set, then rather than continuing to run the commands in event 100 , the game will stop and switch to running the commands in event 101 instead. In total, flags allows you to save permanently when some event occurs, and conditionally split two different possible actions to take into two separate events.","title":"2.3.1 - Flags"},{"location":"guide/tsc/chest/#232-a-chest-with-a-weapon","text":"Cave Story does not have a particularly unified item system -- weapons, life capsules, and items all are given to the player through different TSC commands. For a weapon, the <AM+ command is used, which takes the weapon ID and the amount of ammo to give (or 0 for infinite) as arguments. A simple event (attached to a Chest NPC) to give the player a Polar Star might look like: #0100 <PRI<FLJ1000:0101<FL+1000<CNP0200:0021:0000 <MSGOpened the chest.<NOD<GIT0002<AM+0002:0000<CLR Got the =Polar Star=!<WAI0160<NOD<CLO<END #0101 <PRI<MSGEmpty.<NOD<CLO<END Note the use of the flag 1000 here. Once the chest is opened for the first time, the flag will be set, and subsequent interactions will instead display \"Empty.\" A few other new commands: <CNP functions similar to <DNP , but changes the type of the NPC instead. Here we change the associated Chest NPC (#15) to an Opened Chest NPC (#21). <GIT displays an image of an item above the textbox, separate from actually giving the item. <WAI simply waits the specified number of frames. This is used in vanilla Cave Story to wait for all the sounds to finish playing (although this chest does not include them). Additionally, your Chest NPC should have flag 1000 set as its Flag ID. The code for the Chest NPC is set up to switch immediately to being opened if its Flag ID is set, so re-entering the room will leave it open.","title":"2.3.2 - A chest with a weapon"},{"location":"guide/tsc/door/","text":"2.2 - Making a door Doors in Cave Story are made using NPCs that run an event in your text script when interacted with. A basic one can be made by placing a Null NPC and check its Interactable NPC Bit . Then, construct a TSC event like so: #0100 <PRI<FAO0000<TRAarguments... The <PRI command prevents the player (and anything else) from moving, and the <FAO command starts a fade out. The <TRA command is then responsible for moving the player to a new Stage , so its arguments are dependent on where you want to go. It takes the following: <TRAnew stage ID:new event ID:starting x position:starting y position So if you wanted to take a player to Stage #2 at position (2, 1), then it might look like #0100 <PRI<FAO0000<TRA0002:0090:0002:0001<END The \"new Event ID\" represents an event in the text script of the new stage, which is crucial: if you don't have some type of event set up in the other stage, then there will be nothing to perform the fade back in after the fade out! For this example, #0090 in stage #2 might look like: #0090 <MNA<CMU0008<FAI0000<END Here, <MNA displays the new stage name, and <CMU sets the music track to be played. Then <FAI fades the game back in. Once you have your events set up, you can set the event ID on your NPC to e.g. 100 to have your script fire on interaction. If you want to make a closed door that visibly opens when interacted with, you can use a Door NPC rather than a Null NPC. Then, you can use the <DNP and <SOU commands in your event: #0100 <PRI<SOU0011<DNP0100<FAO000<TRA0002:0090:0002:0001<END The <SOU command plays sound 11, which the sound of opening a door. The <DNP command deletes NPCs attached to the specified event, thus removing the door when interacted with.","title":"2.2 - Making a door"},{"location":"guide/tsc/door/#22-making-a-door","text":"Doors in Cave Story are made using NPCs that run an event in your text script when interacted with. A basic one can be made by placing a Null NPC and check its Interactable NPC Bit . Then, construct a TSC event like so: #0100 <PRI<FAO0000<TRAarguments... The <PRI command prevents the player (and anything else) from moving, and the <FAO command starts a fade out. The <TRA command is then responsible for moving the player to a new Stage , so its arguments are dependent on where you want to go. It takes the following: <TRAnew stage ID:new event ID:starting x position:starting y position So if you wanted to take a player to Stage #2 at position (2, 1), then it might look like #0100 <PRI<FAO0000<TRA0002:0090:0002:0001<END The \"new Event ID\" represents an event in the text script of the new stage, which is crucial: if you don't have some type of event set up in the other stage, then there will be nothing to perform the fade back in after the fade out! For this example, #0090 in stage #2 might look like: #0090 <MNA<CMU0008<FAI0000<END Here, <MNA displays the new stage name, and <CMU sets the music track to be played. Then <FAI fades the game back in. Once you have your events set up, you can set the event ID on your NPC to e.g. 100 to have your script fire on interaction. If you want to make a closed door that visibly opens when interacted with, you can use a Door NPC rather than a Null NPC. Then, you can use the <DNP and <SOU commands in your event: #0100 <PRI<SOU0011<DNP0100<FAO000<TRA0002:0090:0002:0001<END The <SOU command plays sound 11, which the sound of opening a door. The <DNP command deletes NPCs attached to the specified event, thus removing the door when interacted with.","title":"2.2 - Making a door"}]}